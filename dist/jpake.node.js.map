{"version":3,"sources":["webpack://jpake/webpack/universalModuleDefinition","webpack://jpake/./src/jpake.ts","webpack://jpake/./src/utils.ts","webpack://jpake/./node_modules/crypto-js/core.js","webpack://jpake/./node_modules/crypto-js/sha256.js","webpack://jpake/./node_modules/noble-secp256k1/index.js","webpack://jpake/external \"crypto\"","webpack://jpake/webpack/bootstrap","webpack://jpake/webpack/startup"],"names":["root","factory","exports","module","define","amd","this","ZEROPOINT","secp","Point","JPAKESTATEENUM","CURVE","Gx","Gy","Object","freeze","JPAKESTATE_INITIALISED","JPAKESTATE_WAITFORROUND1MSG","JPAKESTATE_WAITFORROUND2MSG","JPAKESTATE_KEYCOMPUTED","secret","hashFn","SHA256Hash","s","mod","BigInt","n","x1","randBetween","x2","G","state","x","Generator","y","v","t","multiply","equals","chal","asBase64String","c","r","tx","ty","add","msgObj","fromBase64String","x1G","x2G","pubVar","x1Gx","x1Gy","x2Gx","x2Gy","x1ZKP","computeZKP","x2ZKP","JSON","stringify","jsonStringFromB","otherPubVars","parse","otherx1G","otherx2G","x1Proof","checkZKPSimpler","x2Proof","x2s","A","Ax","Ay","xsZKP","otherA","B","ZKPGenerator","Ka","subtract","sharedKey","base64","BigIntBase64","getRandomBits","bitLength","randBytes","byteLength","uint8Buf","Uint8Array","window","crypto","getRandomValues","process","versions","randomBytes","buffer","Error","getRandomBytes","Math","ceil","bitLengthMod8","fromBuffer","buf","ret","i","values","bi","a","bits","min","max","RangeError","interval","bitLen","rnd","add0x","pad64HexString","toString","padStart","toHash","fromInt","str","toInt","digits","split","digitsMap","length","result","leftoverBytes","numPadBytes","Number","substr","Array","join","digitsStr","numPadChars","CryptoJS","undefined","msCrypto","global","err","cryptoSecureRandomInt","Uint32Array","readInt32LE","create","F","obj","subtype","prototype","C","C_lib","lib","Base","extend","overrides","mixIn","hasOwnProperty","init","$super","apply","arguments","instance","properties","propertyName","clone","WordArray","words","sigBytes","encoder","Hex","concat","wordArray","thisWords","thatWords","thisSigBytes","thatSigBytes","clamp","thatByte","call","slice","random","nBytes","push","C_enc","enc","hexChars","bite","hexStr","hexStrLength","parseInt","Latin1","latin1Chars","String","fromCharCode","latin1Str","latin1StrLength","charCodeAt","Utf8","decodeURIComponent","escape","e","utf8Str","unescape","encodeURIComponent","BufferedBlockAlgorithm","reset","_data","_nDataBytes","_append","data","_process","doFlush","processedWords","dataWords","dataSigBytes","blockSize","nBlocksReady","nWordsReady","_minBufferSize","nBytesReady","offset","_doProcessBlock","splice","C_algo","Hasher","cfg","_doReset","update","messageUpdate","finalize","_doFinalize","_createHelper","hasher","message","_createHmacHelper","key","HMAC","algo","H","K","isPrime","sqrtN","sqrt","factor","getFractionalBits","nPrime","pow","W","SHA256","_hash","M","b","d","f","g","h","gamma0x","gamma0","gamma1x","gamma1","maj","sigma0","t1","nBitsTotal","nBitsLeft","floor","HmacSHA256","defineProperty","value","P","beta","P_DIV4_1","weistrass","USE_ENDOMORPHISM","JacobianPoint","z","p","TypeError","points","toInv","nums","len","scratch","acc","invert","tmp","invertBatch","map","toAffine","toAffineBatch","fromAffine","other","az2","az3","bz2","bz3","X1","Y1","Z1","D","E","X3","Y3","Z3","X2","Y2","Z2","Z1Z1","Z2Z2","U1","S1","S2","double","ZERO","HH","HHH","V","scalar","k1neg","k1","k2neg","k2","splitScalarEndo","k1p","k2p","negate","windows","base","affinePoint","BASE","_WINDOW_SIZE","precomputes","pointPrecomputes","get","precomputeWindow","normalizeZ","set","windowSize","mask","maxNumber","shiftBy","wbits","cached","abs","point","fake","f1p","f2p","wNAF","invZ","invZ2","WeakMap","delete","bytes","bytesToNumber","powMod","assertValidity","hex","hexToBytes","fromX","header","fromCompressedHex","fromUncompressedHex","privateKey","normalizePrivateKey","msgHash","signature","recovery","sign","normalizeSignature","rinv","hexToNumber","P_","fromHex","pad64","sP","multiplyUnsafe","hG","isCompressed","toHex","toRawBytes","sliceDer","Signature","bytesToHex","check1","parseByte","check2","rEnd","sLen","sStart","sHex","numberToHex","rHex","rLen","concatBytes","arrays","reduce","arr","pad","uint8a","num","pad32b","array","j","power","order","res","number","modulo","gcd","u","q","m","egcd","k","a1","b1","c1","c2","isValidPrivateKey","calcQRSFromK","msg","priv","normalizePublicKey","publicKey","isPub","item","async","taggedHash","tag","messages","tagB","tagH","utils","sha256","createChallenge","rx","toRawX","hasEvenY","SignResult","getPublicKey","fromPrivateKey","recoverPublicKey","fromSignature","getSharedSecret","privateA","publicB","shared","recovered","canonical","h1","h1n","fill","b0","from","hmacSha256","T","qrs","getQRSrfc6979","adjustedS","sig","hashed","verify","hash","delta","truncateHash","pubKey","s1","Ghs1","Prs1","SchnorrSignature","schnorrVerify","sG","eP","R","schnorr","toHexX","auxRand","randomPrivateKey","d0","rand","k0","_setWindowSize","bytesLength","subtle","digest","createHash","ckey","importKey","name","createHmac","require","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__"],"mappings":"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","file":"jpake.node.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"jpake\"] = factory();\n\telse\n\t\troot[\"jpake\"] = factory();\n})(this, function() {\nreturn ","import * as secp from \"noble-secp256k1\";\r\nimport {randBetween, asBase64String, mod, SHA256Hash, fromBase64String, BigIntBase64} from './utils'\r\n\r\n// see: https://billatnapier.medium.com/password-juggling-in-discrete-logs-and-elliptic-curves-a82d5926d26d\r\n// https://asecuritysite.com/encryption/jpake2\r\nconst ZEROPOINT = new secp.Point(0n, 0n)\r\nconst BASEPOINT = new secp.Point(secp.CURVE.Gx, secp.CURVE.Gy)\r\n\r\ntype ZKPMsg = {\r\n    tx: string,\r\n    ty: string,\r\n    r: string,\r\n    c: string,\r\n}\r\n\r\nconst JPAKESTATEENUM = Object.freeze({\r\n    JPAKESTATE_INITIALISED: 0,\r\n\tJPAKESTATE_WAITFORROUND1MSG: 1,\r\n\tJPAKESTATE_WAITFORROUND2MSG: 2, \r\n\tJPAKESTATE_KEYCOMPUTED: 3,\r\n})\r\n\r\nexport class JPake {\r\n    \r\n    // Private Variables\r\n    private x1:  bigint\r\n    private x2:  bigint\r\n    private s:   bigint\r\n\r\n    // Public Variables\r\n    x1G: secp.Point\r\n    x2G: secp.Point\r\n\r\n    // Received Variables / cached variables\r\n    x2s: bigint\r\n    otherx1G: secp.Point\r\n    otherx2G: secp.Point\r\n    G: secp.Point\r\n    hashFn: (str: string) => string\r\n    state: number\r\n\r\n    constructor(secret: string, hashFn: (str: string) => string = SHA256Hash) { \r\n        this.hashFn = hashFn\r\n\r\n        // Compute a simple hash of our secret\r\n        this.s = mod( BigInt(\"0x\" + this.hashFn(secret)), secp.CURVE.n )\r\n\r\n        this.x1 = randBetween(0n, secp.CURVE.n - 1n)\r\n        this.x2 = randBetween(0n, secp.CURVE.n - 1n)\r\n\r\n        const G = new secp.Point(secp.CURVE.Gx, secp.CURVE.Gy );\r\n        this.G = G \r\n        \r\n        this.state = JPAKESTATEENUM.JPAKESTATE_INITIALISED\r\n    }\r\n\r\n    setRandomState(x1: bigint, x2: bigint) {\r\n        this.x1 = x1\r\n        this.x2 = x2\r\n    }\r\n\r\n    // ZKP checks not implemented into protocol yet.\r\n    computeZKP(x: bigint, Generator: secp.Point, y: secp.Point = ZEROPOINT) : object{\r\n        // Computes a ZKP for x on Generator. We use the Fiat-Shamir heuristic:\r\n        // https://en.wikipedia.org/wiki/Fiat%E2%80%93Shamir_heuristic\r\n        // i.e. prove that we know x such that y = x.Generator\r\n        // Note that we differentiate between the point G on the curve, and the\r\n        // Generator used to compute the ZKP\r\n\r\n        // 1. Pick a random v \\in Z_q* and compute t = vG\r\n        const v = randBetween(0n, secp.CURVE.n - 1n)\r\n        const t = Generator.multiply(v)\r\n\r\n        // 2. Compute c = H(g, y, t) where H() is a cryptographic hash fn\r\n        y = y.equals(ZEROPOINT) ? Generator.multiply(x) : y\r\n        const chal = asBase64String(Generator.x) + asBase64String(Generator.y) + asBase64String(t.x) + asBase64String(t.y) + asBase64String(y.x) + asBase64String(y.y)\r\n        const c = BigInt(\"0x\"+this.hashFn(chal))\r\n\r\n        // 3. Compute r = v - cx\r\n        const r = mod((v-c*x), secp.CURVE.n)\r\n\r\n        // The resulting proof is the pair (t, r).\r\n        // you can use this to verify the pair by\r\n        // calculating c = H(g, y, t) and checking if t == rG * cy.\r\n        // Here, we send over c for simplicity.\r\n        return {\r\n            tx: asBase64String(t.x),\r\n            ty: asBase64String(t.y),\r\n            r: asBase64String(r),\r\n            c: asBase64String(c),\r\n        }\r\n    }\r\n\r\n    checkZKP(tx: bigint, ty: bigint, r: bigint, G: secp.Point, y: secp.Point): boolean {\r\n        const chal = asBase64String(G.x) + asBase64String(G.y) + asBase64String(tx) + asBase64String(ty) + asBase64String(y.x) + asBase64String(y.y)\r\n        \r\n        const c = BigInt(\"0x\" + this.hashFn(chal))\r\n\r\n        var Vcheck = G.multiply(r).add(y.multiply(c))\r\n        return Vcheck.equals(new secp.Point(tx, ty))\r\n    }\r\n\r\n    checkZKPSimpler(msgObj: ZKPMsg, Generator: secp.Point, y: secp.Point) {\r\n\r\n        const tx = fromBase64String(msgObj.tx)\r\n        const ty = fromBase64String(msgObj.ty)\r\n        const r = fromBase64String(msgObj.r)\r\n        const c = fromBase64String(msgObj.c)\r\n\r\n        var Vcheck = Generator.multiply(r).add(y.multiply(c))\r\n        return Vcheck.equals(new secp.Point(tx, ty))\r\n    }\r\n\r\n    GetRound1Message(): string{\r\n\r\n        if (this.state != JPAKESTATEENUM.JPAKESTATE_INITIALISED) {\r\n            throw \"Wrong state!\"\r\n        }\r\n\r\n        this.x1G = this.G.multiply(this.x1)\r\n        this.x2G = this.G.multiply(this.x2) \r\n\r\n        var pubVar = {\r\n            x1Gx: asBase64String(this.x1G.x),\r\n            x1Gy: asBase64String(this.x1G.y),\r\n            x2Gx: asBase64String(this.x2G.x),\r\n            x2Gy: asBase64String(this.x2G.y),\r\n\r\n            x1ZKP: this.computeZKP(this.x1, this.G, this.x1G),\r\n            x2ZKP: this.computeZKP(this.x2, this.G, this.x2G),\r\n        }\r\n\r\n        this.state = JPAKESTATEENUM.JPAKESTATE_WAITFORROUND1MSG\r\n        return JSON.stringify(pubVar);\r\n    }\r\n\r\n    GetRound2Message(jsonStringFromB: string): string{\r\n        if (this.state != JPAKESTATEENUM.JPAKESTATE_WAITFORROUND1MSG) {\r\n            throw \"Wrong state!\"\r\n        }\r\n        \r\n        // In Round 1, we receive x1G and x2G from Bob, and possibly knowledge proofs for x1 and x2\r\n        const otherPubVars = JSON.parse(jsonStringFromB)\r\n        const otherx1G = new secp.Point(fromBase64String(otherPubVars.x1Gx), fromBase64String(otherPubVars.x1Gy)) // also x3G and x4G from Bob if you are following the paper\r\n        const otherx2G = new secp.Point(fromBase64String(otherPubVars.x2Gx), fromBase64String(otherPubVars.x2Gy))\r\n        \r\n        // validate ZKPs\r\n        const x1Proof = this.checkZKPSimpler(otherPubVars.x1ZKP, this.G, otherx1G)\r\n        const x2Proof = this.checkZKPSimpler(otherPubVars.x2ZKP, this.G, otherx2G)\r\n\r\n        if (!(x1Proof && x2Proof)) {\r\n            throw \"Round1 Knowledge Proof Not verified!\"\r\n        }\r\n\r\n        // These are variables which can be cached for other steps \r\n        this.otherx1G = otherx1G\r\n        this.otherx2G = otherx2G\r\n        this.x2s = this.x2 * this.s\r\n\r\n        // A = (G1 + G3 + G4) x [x2*s]\r\n        const Generator = this.x1G.add(otherx1G).add(otherx2G) // As per the RFC, the 2nd round generator is G1 + G3 + G4 in the EC setting\r\n        const A = Generator.multiply(this.x2s)\r\n\r\n        this.state = JPAKESTATEENUM.JPAKESTATE_WAITFORROUND2MSG\r\n        return JSON.stringify({\r\n            Ax: asBase64String(A.x),\r\n            Ay: asBase64String(A.y),\r\n\r\n            xsZKP: this.computeZKP(this.x2s, Generator, A)\r\n        })\r\n    }\r\n\r\n    ComputeSharedKey(jsonStringFromB: string) : string {\r\n\r\n        if( this.state != JPAKESTATEENUM.JPAKESTATE_WAITFORROUND2MSG) {\r\n            throw \"Wrong state!\"\r\n        }\r\n\r\n        const otherA = JSON.parse(jsonStringFromB)\r\n        const B = new secp.Point(fromBase64String(otherA.Ax), fromBase64String(otherA.Ay))\r\n        \r\n        const ZKPGenerator = this.x1G.add(this.x2G).add(this.otherx1G)\r\n        const xsProof = this.checkZKPSimpler(otherA.xsZKP, ZKPGenerator, B)\r\n        if (!xsProof) {\r\n            throw \"Round2 Knowledge Proof Not verified!\"\r\n        }\r\n\r\n        // Ka = (B - (G4 x [x2*s])) x [x2]\r\n        const Ka = B.subtract(this.otherx2G.multiply(this.x2s)).multiply(this.x2)\r\n        const sharedKey = this.hashFn(asBase64String(Ka.x))\r\n\r\n        this.state = JPAKESTATEENUM.JPAKESTATE_KEYCOMPUTED\r\n        return sharedKey\r\n    }\r\n}\r\n\r\n\r\nexport const base64 = BigIntBase64","import sha256  from 'crypto-js/sha256'\r\n\r\n\r\n/* HELPER FUNCTIONS */\r\nfunction modNum (x: number, n: number): number {\r\n    return ((x % n) + n) % n\r\n}\r\n\r\nexport function mod (x: bigint, n: bigint): bigint {\r\n    return ((x % n) + n) % n\r\n}\r\n  \r\nfunction getRandomBytes (byteLength: number): Uint8Array {\r\n    const uint8Buf = new Uint8Array(byteLength)\r\n    if (typeof window == 'object' && 'crypto' in window) {\r\n        return window.crypto.getRandomValues(uint8Buf);\r\n    }\r\n    else if (typeof process === 'object' && 'node' in process.versions) {\r\n        const { randomBytes } = require('crypto');\r\n        return new Uint8Array(randomBytes(byteLength).buffer);\r\n    }\r\n    else {\r\n        throw new Error(\"The environment doesn't have randomBytes function\");\r\n    }\r\n}\r\n\r\nfunction getRandomBits (bitLength: number): Uint8Array {\r\n    const byteLength = Math.ceil(bitLength / 8) \r\n    const randBytes = getRandomBytes(byteLength)\r\n\r\n    const bitLengthMod8 = modNum(bitLength, 8)\r\n    if (bitLengthMod8) {\r\n        // randBytes[0] is the MSByte\r\n        // Fill the MSByte with leading zeros to produce the correct\r\n        // bit length\r\n        randBytes[0] = randBytes[0] & (2 ** bitLengthMod8 - 1)\r\n    }\r\n    return randBytes\r\n}\r\n\r\nexport function fromBuffer (buf: Uint8Array) {\r\n    let ret = 0n\r\n    for (const i of buf.values()) {\r\n        const bi = BigInt(i)\r\n        ret = (ret << BigInt(8)) + bi\r\n    }\r\n    return ret\r\n}\r\n\r\nfunction bitLength (a: number|bigint) {\r\n    a = BigInt(a)\r\n    if (a === 1n) { return 1 }\r\n    let bits = 1\r\n    do {\r\n        bits++\r\n    } while ((a >>= 1n) > 1n)\r\n    return bits\r\n}\r\n\r\nexport function randBetween (min: bigint, max: bigint): bigint {\r\n    if (max <= 0n || min < 0n || max <= min) throw new RangeError('Arguments MUST be: max > 0 && min >=0 && max > min')\r\n    const interval = max - min\r\n    const bitLen = bitLength(interval)\r\n    let rnd\r\n    do {\r\n      const buf = getRandomBits(bitLen)\r\n      rnd = fromBuffer(buf)\r\n    } while (rnd > interval)\r\n    const randnum = rnd + min\r\n    return randnum\r\n}\r\n\r\nexport function asPad64HexString(x: bigint, add0x: boolean = true): string {\r\n    const pad64HexString = x.toString(16).padStart(64, '0')\r\n    return add0x ? '0x' + pad64HexString : pad64HexString\r\n}\r\n\r\nexport function SHA256Hash(toHash: string): string {\r\n    var hash = sha256(toHash).toString()\r\n    return hash\r\n}\r\n\r\nexport function asBase64String( x: bigint ): string {\r\n    return BigIntBase64.fromInt(x)\r\n}\r\n\r\nexport function fromBase64String(str: string): bigint {\r\n    return BigIntBase64.toInt(str)\r\n}\r\n\r\n\r\nexport const BigIntBase64 = (function () {\r\n    var digitsStr = \r\n    //   0       8       16      24      32      40      48      56     63\r\n    //   v       v       v       v       v       v       v       v      v\r\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\n    var digits = digitsStr.split('');\r\n    var digitsMap: {[digit: string]: bigint} = {};\r\n    for (var i = 0; i < digits.length; i++) {\r\n        digitsMap[digits[i]] = BigInt(i);\r\n    }\r\n    return {\r\n        fromInt: function(x: bigint) {\r\n            // Fast base64 encoding based on RFC\r\n            var result = ''\r\n            const byteLen = Math.ceil(bitLength(x) / 8)\r\n            const leftoverBytes = (byteLen % 3)\r\n            const numPadBytes = leftoverBytes == 0 ? 0 : 3 - leftoverBytes\r\n            x <<= BigInt(numPadBytes * 8)\r\n            while (true) {\r\n                result = digits[Number(x & 0x3fn)] + result; // this is safe because of the bitshifting\r\n                x >>= 6n; // Only good for us with unsigned integers? this should break for signed integers.\r\n                if (x === 0n)\r\n                    break;\r\n            }\r\n            // Replace the last numPadBytes characters with \"=\"\r\n            result = result.substr(0, result.length - numPadBytes) + Array(numPadBytes+1).join(\"=\")\r\n\r\n            return result;\r\n        },\r\n        toInt: function(digitsStr: string) {\r\n            var result = 0n;            \r\n            var digits = digitsStr.split('');\r\n\r\n            var numPadChars = 0\r\n            for (let i = 0; i < 2; i++ ){\r\n                if ( digits[digits.length - i - 1]  == '=' ) {\r\n                    digits[digits.length - i - 1] = \"A\"\r\n                    numPadChars ++\r\n                }\r\n            }\r\n            for (var i = 0; i < digits.length; i++) {\r\n                result = (result << 6n) + digitsMap[digits[i]];\r\n            }\r\n            // Right shift result back based on the correct number of padded chars\r\n            result >>= BigInt(8*numPadChars)\r\n            return result;\r\n        }\r\n    };\r\n})();\r\n\r\n\r\n// export const UnsignedBigIntBase64 = (function () {\r\n//     const byteToHex: Array<string> = new Array(0xff);\r\n//     for (let n = 0; n <= 0xff; ++n)\r\n//     {\r\n//         const hexOctet = n.toString(16).padStart(2, \"0\");\r\n//         byteToHex.push(hexOctet);\r\n//     }\r\n\r\n//     return {\r\n//         fromInt: function(x: bigint) {\r\n//             var byteStringArray = x.toString(8).split('');\r\n//             var u8 = new Uint8Array(byteStringArray.length);\r\n        \r\n//             // And then we can iterate each element by one\r\n//             for ( var i = 0; i < byteStringArray.length; i++ ) {\r\n//                 u8[i] = Number(x & 0xfn); // 0xf == 1 byte\r\n//                 x >>= 2n   // THIS DOES NOT WORK WITH NEGATIVE NUMBERS!\r\n//             }\r\n//             return u8;\r\n//         },\r\n//         toInt: function(digitsStr: string) {\r\n//             const bytes = window.atob(digitsStr)\r\n//             var hex = new Array(bytes.length);\r\n//             for (let i = 0; i < bytes.length; ++i) {\r\n//                 hex[i] = byteToHex[bytes[i]]\r\n//             }\r\n//             return hex.join('')\r\n//         }\r\n//     };\r\n// })();\r\n\r\n// const bytes = atob(data);\r\n//     let length = bytes.length;\r\n//     let out = new Uint8Array(length);\r\n\r\n//     // Loop and convert.\r\n//     while (length--) {\r\n//         out[length] = bytes.charCodeAt(length);\r\n//     }\r\n\r\n//     return new Blob([out], { type: type });\r\n\r\n\r\n// export const asd = (function(){\r\n//     \"use strict\";\r\n    \r\n//     var chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\n    \r\n//     // Use a lookup table to find the index.\r\n//     var lookup = new Uint8Array(256);\r\n//     for (var i = 0; i < chars.length; i++) {\r\n//         lookup[chars.charCodeAt(i)] = i;\r\n//     }\r\n\r\n//     return {\r\n//         fromInt: function(x: bigint) {\r\n//             var byteStringArray = x.toString(8).split('');\r\n//             var u8 = new Uint8Array(byteStringArray.length);\r\n//             var base64 = \"\"\r\n        \r\n//             // And then we can iterate each element by one\r\n//             for ( var i = 0; i < byteStringArray.length; i+=3 ) {\r\n//                 u8[i] = Number(x & 0xfn); // 0xf == 1 byte\r\n//                 x >>= 2n   // THIS DOES NOT WORK WITH NEGATIVE NUMBERS!\r\n//             }\r\n//             return u8;\r\n//         },\r\n//     }\r\n    \r\n//     encode = function(arraybuffer) {\r\n//         var bytes = new Uint8Array(arraybuffer),\r\n//         i, len = bytes.length, base64 = \"\";\r\n    \r\n//         for (i = 0; i < len; i+=3) {\r\n//             base64 += chars[bytes[i] >> 2];\r\n//             base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\r\n//             base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\r\n//             base64 += chars[bytes[i + 2] & 63];\r\n//         }\r\n    \r\n//         if ((len % 3) === 2) {\r\n//         base64 = base64.substring(0, base64.length - 1) + \"=\";\r\n//         } else if (len % 3 === 1) {\r\n//         base64 = base64.substring(0, base64.length - 2) + \"==\";\r\n//         }\r\n    \r\n//         return base64;\r\n//     };\r\n    \r\n//     exports.decode =  function(base64) {\r\n//         var bufferLength = base64.length * 0.75,\r\n//         len = base64.length, i, p = 0,\r\n//         encoded1, encoded2, encoded3, encoded4;\r\n    \r\n//         if (base64[base64.length - 1] === \"=\") {\r\n//         bufferLength--;\r\n//         if (base64[base64.length - 2] === \"=\") {\r\n//             bufferLength--;\r\n//         }\r\n//         }\r\n    \r\n//         var arraybuffer = new ArrayBuffer(bufferLength),\r\n//         bytes = new Uint8Array(arraybuffer);\r\n    \r\n//         for (i = 0; i < len; i+=4) {\r\n//         encoded1 = lookup[base64.charCodeAt(i)];\r\n//         encoded2 = lookup[base64.charCodeAt(i+1)];\r\n//         encoded3 = lookup[base64.charCodeAt(i+2)];\r\n//         encoded4 = lookup[base64.charCodeAt(i+3)];\r\n    \r\n//         bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\r\n//         bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\r\n//         bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\r\n//         }\r\n    \r\n//         return arraybuffer;\r\n//     };\r\n//     })();\r\n    ",";(function (root, factory) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory();\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\troot.CryptoJS = factory();\n\t}\n}(this, function () {\n\n\t/*globals window, global, require*/\n\n\t/**\n\t * CryptoJS core components.\n\t */\n\tvar CryptoJS = CryptoJS || (function (Math, undefined) {\n\n\t    var crypto;\n\n\t    // Native crypto from window (Browser)\n\t    if (typeof window !== 'undefined' && window.crypto) {\n\t        crypto = window.crypto;\n\t    }\n\n\t    // Native (experimental IE 11) crypto from window (Browser)\n\t    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {\n\t        crypto = window.msCrypto;\n\t    }\n\n\t    // Native crypto from global (NodeJS)\n\t    if (!crypto && typeof global !== 'undefined' && global.crypto) {\n\t        crypto = global.crypto;\n\t    }\n\n\t    // Native crypto import via require (NodeJS)\n\t    if (!crypto && typeof require === 'function') {\n\t        try {\n\t            crypto = require('crypto');\n\t        } catch (err) {}\n\t    }\n\n\t    /*\n\t     * Cryptographically secure pseudorandom number generator\n\t     *\n\t     * As Math.random() is cryptographically not safe to use\n\t     */\n\t    var cryptoSecureRandomInt = function () {\n\t        if (crypto) {\n\t            // Use getRandomValues method (Browser)\n\t            if (typeof crypto.getRandomValues === 'function') {\n\t                try {\n\t                    return crypto.getRandomValues(new Uint32Array(1))[0];\n\t                } catch (err) {}\n\t            }\n\n\t            // Use randomBytes method (NodeJS)\n\t            if (typeof crypto.randomBytes === 'function') {\n\t                try {\n\t                    return crypto.randomBytes(4).readInt32LE();\n\t                } catch (err) {}\n\t            }\n\t        }\n\n\t        throw new Error('Native crypto module could not be used to get secure random number.');\n\t    };\n\n\t    /*\n\t     * Local polyfill of Object.create\n\n\t     */\n\t    var create = Object.create || (function () {\n\t        function F() {}\n\n\t        return function (obj) {\n\t            var subtype;\n\n\t            F.prototype = obj;\n\n\t            subtype = new F();\n\n\t            F.prototype = null;\n\n\t            return subtype;\n\t        };\n\t    }())\n\n\t    /**\n\t     * CryptoJS namespace.\n\t     */\n\t    var C = {};\n\n\t    /**\n\t     * Library namespace.\n\t     */\n\t    var C_lib = C.lib = {};\n\n\t    /**\n\t     * Base object for prototypal inheritance.\n\t     */\n\t    var Base = C_lib.Base = (function () {\n\n\n\t        return {\n\t            /**\n\t             * Creates a new object that inherits from this object.\n\t             *\n\t             * @param {Object} overrides Properties to copy into the new object.\n\t             *\n\t             * @return {Object} The new object.\n\t             *\n\t             * @static\n\t             *\n\t             * @example\n\t             *\n\t             *     var MyType = CryptoJS.lib.Base.extend({\n\t             *         field: 'value',\n\t             *\n\t             *         method: function () {\n\t             *         }\n\t             *     });\n\t             */\n\t            extend: function (overrides) {\n\t                // Spawn\n\t                var subtype = create(this);\n\n\t                // Augment\n\t                if (overrides) {\n\t                    subtype.mixIn(overrides);\n\t                }\n\n\t                // Create default initializer\n\t                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {\n\t                    subtype.init = function () {\n\t                        subtype.$super.init.apply(this, arguments);\n\t                    };\n\t                }\n\n\t                // Initializer's prototype is the subtype object\n\t                subtype.init.prototype = subtype;\n\n\t                // Reference supertype\n\t                subtype.$super = this;\n\n\t                return subtype;\n\t            },\n\n\t            /**\n\t             * Extends this object and runs the init method.\n\t             * Arguments to create() will be passed to init().\n\t             *\n\t             * @return {Object} The new object.\n\t             *\n\t             * @static\n\t             *\n\t             * @example\n\t             *\n\t             *     var instance = MyType.create();\n\t             */\n\t            create: function () {\n\t                var instance = this.extend();\n\t                instance.init.apply(instance, arguments);\n\n\t                return instance;\n\t            },\n\n\t            /**\n\t             * Initializes a newly created object.\n\t             * Override this method to add some logic when your objects are created.\n\t             *\n\t             * @example\n\t             *\n\t             *     var MyType = CryptoJS.lib.Base.extend({\n\t             *         init: function () {\n\t             *             // ...\n\t             *         }\n\t             *     });\n\t             */\n\t            init: function () {\n\t            },\n\n\t            /**\n\t             * Copies properties into this object.\n\t             *\n\t             * @param {Object} properties The properties to mix in.\n\t             *\n\t             * @example\n\t             *\n\t             *     MyType.mixIn({\n\t             *         field: 'value'\n\t             *     });\n\t             */\n\t            mixIn: function (properties) {\n\t                for (var propertyName in properties) {\n\t                    if (properties.hasOwnProperty(propertyName)) {\n\t                        this[propertyName] = properties[propertyName];\n\t                    }\n\t                }\n\n\t                // IE won't copy toString using the loop above\n\t                if (properties.hasOwnProperty('toString')) {\n\t                    this.toString = properties.toString;\n\t                }\n\t            },\n\n\t            /**\n\t             * Creates a copy of this object.\n\t             *\n\t             * @return {Object} The clone.\n\t             *\n\t             * @example\n\t             *\n\t             *     var clone = instance.clone();\n\t             */\n\t            clone: function () {\n\t                return this.init.prototype.extend(this);\n\t            }\n\t        };\n\t    }());\n\n\t    /**\n\t     * An array of 32-bit words.\n\t     *\n\t     * @property {Array} words The array of 32-bit words.\n\t     * @property {number} sigBytes The number of significant bytes in this word array.\n\t     */\n\t    var WordArray = C_lib.WordArray = Base.extend({\n\t        /**\n\t         * Initializes a newly created word array.\n\t         *\n\t         * @param {Array} words (Optional) An array of 32-bit words.\n\t         * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.lib.WordArray.create();\n\t         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);\n\t         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);\n\t         */\n\t        init: function (words, sigBytes) {\n\t            words = this.words = words || [];\n\n\t            if (sigBytes != undefined) {\n\t                this.sigBytes = sigBytes;\n\t            } else {\n\t                this.sigBytes = words.length * 4;\n\t            }\n\t        },\n\n\t        /**\n\t         * Converts this word array to a string.\n\t         *\n\t         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n\t         *\n\t         * @return {string} The stringified word array.\n\t         *\n\t         * @example\n\t         *\n\t         *     var string = wordArray + '';\n\t         *     var string = wordArray.toString();\n\t         *     var string = wordArray.toString(CryptoJS.enc.Utf8);\n\t         */\n\t        toString: function (encoder) {\n\t            return (encoder || Hex).stringify(this);\n\t        },\n\n\t        /**\n\t         * Concatenates a word array to this word array.\n\t         *\n\t         * @param {WordArray} wordArray The word array to append.\n\t         *\n\t         * @return {WordArray} This word array.\n\t         *\n\t         * @example\n\t         *\n\t         *     wordArray1.concat(wordArray2);\n\t         */\n\t        concat: function (wordArray) {\n\t            // Shortcuts\n\t            var thisWords = this.words;\n\t            var thatWords = wordArray.words;\n\t            var thisSigBytes = this.sigBytes;\n\t            var thatSigBytes = wordArray.sigBytes;\n\n\t            // Clamp excess bits\n\t            this.clamp();\n\n\t            // Concat\n\t            if (thisSigBytes % 4) {\n\t                // Copy one byte at a time\n\t                for (var i = 0; i < thatSigBytes; i++) {\n\t                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);\n\t                }\n\t            } else {\n\t                // Copy one word at a time\n\t                for (var i = 0; i < thatSigBytes; i += 4) {\n\t                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];\n\t                }\n\t            }\n\t            this.sigBytes += thatSigBytes;\n\n\t            // Chainable\n\t            return this;\n\t        },\n\n\t        /**\n\t         * Removes insignificant bits.\n\t         *\n\t         * @example\n\t         *\n\t         *     wordArray.clamp();\n\t         */\n\t        clamp: function () {\n\t            // Shortcuts\n\t            var words = this.words;\n\t            var sigBytes = this.sigBytes;\n\n\t            // Clamp\n\t            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);\n\t            words.length = Math.ceil(sigBytes / 4);\n\t        },\n\n\t        /**\n\t         * Creates a copy of this word array.\n\t         *\n\t         * @return {WordArray} The clone.\n\t         *\n\t         * @example\n\t         *\n\t         *     var clone = wordArray.clone();\n\t         */\n\t        clone: function () {\n\t            var clone = Base.clone.call(this);\n\t            clone.words = this.words.slice(0);\n\n\t            return clone;\n\t        },\n\n\t        /**\n\t         * Creates a word array filled with random bytes.\n\t         *\n\t         * @param {number} nBytes The number of random bytes to generate.\n\t         *\n\t         * @return {WordArray} The random word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.lib.WordArray.random(16);\n\t         */\n\t        random: function (nBytes) {\n\t            var words = [];\n\n\t            for (var i = 0; i < nBytes; i += 4) {\n\t                words.push(cryptoSecureRandomInt());\n\t            }\n\n\t            return new WordArray.init(words, nBytes);\n\t        }\n\t    });\n\n\t    /**\n\t     * Encoder namespace.\n\t     */\n\t    var C_enc = C.enc = {};\n\n\t    /**\n\t     * Hex encoding strategy.\n\t     */\n\t    var Hex = C_enc.Hex = {\n\t        /**\n\t         * Converts a word array to a hex string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The hex string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var hexChars = [];\n\t            for (var i = 0; i < sigBytes; i++) {\n\t                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                hexChars.push((bite >>> 4).toString(16));\n\t                hexChars.push((bite & 0x0f).toString(16));\n\t            }\n\n\t            return hexChars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a hex string to a word array.\n\t         *\n\t         * @param {string} hexStr The hex string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);\n\t         */\n\t        parse: function (hexStr) {\n\t            // Shortcut\n\t            var hexStrLength = hexStr.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < hexStrLength; i += 2) {\n\t                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\n\t            }\n\n\t            return new WordArray.init(words, hexStrLength / 2);\n\t        }\n\t    };\n\n\t    /**\n\t     * Latin1 encoding strategy.\n\t     */\n\t    var Latin1 = C_enc.Latin1 = {\n\t        /**\n\t         * Converts a word array to a Latin1 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The Latin1 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var latin1Chars = [];\n\t            for (var i = 0; i < sigBytes; i++) {\n\t                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                latin1Chars.push(String.fromCharCode(bite));\n\t            }\n\n\t            return latin1Chars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a Latin1 string to a word array.\n\t         *\n\t         * @param {string} latin1Str The Latin1 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);\n\t         */\n\t        parse: function (latin1Str) {\n\t            // Shortcut\n\t            var latin1StrLength = latin1Str.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < latin1StrLength; i++) {\n\t                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\n\t            }\n\n\t            return new WordArray.init(words, latin1StrLength);\n\t        }\n\t    };\n\n\t    /**\n\t     * UTF-8 encoding strategy.\n\t     */\n\t    var Utf8 = C_enc.Utf8 = {\n\t        /**\n\t         * Converts a word array to a UTF-8 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The UTF-8 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            try {\n\t                return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n\t            } catch (e) {\n\t                throw new Error('Malformed UTF-8 data');\n\t            }\n\t        },\n\n\t        /**\n\t         * Converts a UTF-8 string to a word array.\n\t         *\n\t         * @param {string} utf8Str The UTF-8 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);\n\t         */\n\t        parse: function (utf8Str) {\n\t            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n\t        }\n\t    };\n\n\t    /**\n\t     * Abstract buffered block algorithm template.\n\t     *\n\t     * The property blockSize must be implemented in a concrete subtype.\n\t     *\n\t     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0\n\t     */\n\t    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({\n\t        /**\n\t         * Resets this block algorithm's data buffer to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     bufferedBlockAlgorithm.reset();\n\t         */\n\t        reset: function () {\n\t            // Initial values\n\t            this._data = new WordArray.init();\n\t            this._nDataBytes = 0;\n\t        },\n\n\t        /**\n\t         * Adds new data to this block algorithm's buffer.\n\t         *\n\t         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.\n\t         *\n\t         * @example\n\t         *\n\t         *     bufferedBlockAlgorithm._append('data');\n\t         *     bufferedBlockAlgorithm._append(wordArray);\n\t         */\n\t        _append: function (data) {\n\t            // Convert string to WordArray, else assume WordArray already\n\t            if (typeof data == 'string') {\n\t                data = Utf8.parse(data);\n\t            }\n\n\t            // Append\n\t            this._data.concat(data);\n\t            this._nDataBytes += data.sigBytes;\n\t        },\n\n\t        /**\n\t         * Processes available data blocks.\n\t         *\n\t         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n\t         *\n\t         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\n\t         *\n\t         * @return {WordArray} The processed data.\n\t         *\n\t         * @example\n\t         *\n\t         *     var processedData = bufferedBlockAlgorithm._process();\n\t         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');\n\t         */\n\t        _process: function (doFlush) {\n\t            var processedWords;\n\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\t            var dataSigBytes = data.sigBytes;\n\t            var blockSize = this.blockSize;\n\t            var blockSizeBytes = blockSize * 4;\n\n\t            // Count blocks ready\n\t            var nBlocksReady = dataSigBytes / blockSizeBytes;\n\t            if (doFlush) {\n\t                // Round up to include partial blocks\n\t                nBlocksReady = Math.ceil(nBlocksReady);\n\t            } else {\n\t                // Round down to include only full blocks,\n\t                // less the number of blocks that must remain in the buffer\n\t                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n\t            }\n\n\t            // Count words ready\n\t            var nWordsReady = nBlocksReady * blockSize;\n\n\t            // Count bytes ready\n\t            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n\n\t            // Process blocks\n\t            if (nWordsReady) {\n\t                for (var offset = 0; offset < nWordsReady; offset += blockSize) {\n\t                    // Perform concrete-algorithm logic\n\t                    this._doProcessBlock(dataWords, offset);\n\t                }\n\n\t                // Remove processed words\n\t                processedWords = dataWords.splice(0, nWordsReady);\n\t                data.sigBytes -= nBytesReady;\n\t            }\n\n\t            // Return processed words\n\t            return new WordArray.init(processedWords, nBytesReady);\n\t        },\n\n\t        /**\n\t         * Creates a copy of this object.\n\t         *\n\t         * @return {Object} The clone.\n\t         *\n\t         * @example\n\t         *\n\t         *     var clone = bufferedBlockAlgorithm.clone();\n\t         */\n\t        clone: function () {\n\t            var clone = Base.clone.call(this);\n\t            clone._data = this._data.clone();\n\n\t            return clone;\n\t        },\n\n\t        _minBufferSize: 0\n\t    });\n\n\t    /**\n\t     * Abstract hasher template.\n\t     *\n\t     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)\n\t     */\n\t    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({\n\t        /**\n\t         * Configuration options.\n\t         */\n\t        cfg: Base.extend(),\n\n\t        /**\n\t         * Initializes a newly created hasher.\n\t         *\n\t         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hasher = CryptoJS.algo.SHA256.create();\n\t         */\n\t        init: function (cfg) {\n\t            // Apply config defaults\n\t            this.cfg = this.cfg.extend(cfg);\n\n\t            // Set initial values\n\t            this.reset();\n\t        },\n\n\t        /**\n\t         * Resets this hasher to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     hasher.reset();\n\t         */\n\t        reset: function () {\n\t            // Reset data buffer\n\t            BufferedBlockAlgorithm.reset.call(this);\n\n\t            // Perform concrete-hasher logic\n\t            this._doReset();\n\t        },\n\n\t        /**\n\t         * Updates this hasher with a message.\n\t         *\n\t         * @param {WordArray|string} messageUpdate The message to append.\n\t         *\n\t         * @return {Hasher} This hasher.\n\t         *\n\t         * @example\n\t         *\n\t         *     hasher.update('message');\n\t         *     hasher.update(wordArray);\n\t         */\n\t        update: function (messageUpdate) {\n\t            // Append\n\t            this._append(messageUpdate);\n\n\t            // Update the hash\n\t            this._process();\n\n\t            // Chainable\n\t            return this;\n\t        },\n\n\t        /**\n\t         * Finalizes the hash computation.\n\t         * Note that the finalize operation is effectively a destructive, read-once operation.\n\t         *\n\t         * @param {WordArray|string} messageUpdate (Optional) A final message update.\n\t         *\n\t         * @return {WordArray} The hash.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hash = hasher.finalize();\n\t         *     var hash = hasher.finalize('message');\n\t         *     var hash = hasher.finalize(wordArray);\n\t         */\n\t        finalize: function (messageUpdate) {\n\t            // Final message update\n\t            if (messageUpdate) {\n\t                this._append(messageUpdate);\n\t            }\n\n\t            // Perform concrete-hasher logic\n\t            var hash = this._doFinalize();\n\n\t            return hash;\n\t        },\n\n\t        blockSize: 512/32,\n\n\t        /**\n\t         * Creates a shortcut function to a hasher's object interface.\n\t         *\n\t         * @param {Hasher} hasher The hasher to create a helper for.\n\t         *\n\t         * @return {Function} The shortcut function.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);\n\t         */\n\t        _createHelper: function (hasher) {\n\t            return function (message, cfg) {\n\t                return new hasher.init(cfg).finalize(message);\n\t            };\n\t        },\n\n\t        /**\n\t         * Creates a shortcut function to the HMAC's object interface.\n\t         *\n\t         * @param {Hasher} hasher The hasher to use in this HMAC helper.\n\t         *\n\t         * @return {Function} The shortcut function.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);\n\t         */\n\t        _createHmacHelper: function (hasher) {\n\t            return function (message, key) {\n\t                return new C_algo.HMAC.init(hasher, key).finalize(message);\n\t            };\n\t        }\n\t    });\n\n\t    /**\n\t     * Algorithm namespace.\n\t     */\n\t    var C_algo = C.algo = {};\n\n\t    return C;\n\t}(Math));\n\n\n\treturn CryptoJS;\n\n}));",";(function (root, factory) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t(function (Math) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_algo = C.algo;\n\n\t    // Initialization and round constants tables\n\t    var H = [];\n\t    var K = [];\n\n\t    // Compute constants\n\t    (function () {\n\t        function isPrime(n) {\n\t            var sqrtN = Math.sqrt(n);\n\t            for (var factor = 2; factor <= sqrtN; factor++) {\n\t                if (!(n % factor)) {\n\t                    return false;\n\t                }\n\t            }\n\n\t            return true;\n\t        }\n\n\t        function getFractionalBits(n) {\n\t            return ((n - (n | 0)) * 0x100000000) | 0;\n\t        }\n\n\t        var n = 2;\n\t        var nPrime = 0;\n\t        while (nPrime < 64) {\n\t            if (isPrime(n)) {\n\t                if (nPrime < 8) {\n\t                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));\n\t                }\n\t                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));\n\n\t                nPrime++;\n\t            }\n\n\t            n++;\n\t        }\n\t    }());\n\n\t    // Reusable object\n\t    var W = [];\n\n\t    /**\n\t     * SHA-256 hash algorithm.\n\t     */\n\t    var SHA256 = C_algo.SHA256 = Hasher.extend({\n\t        _doReset: function () {\n\t            this._hash = new WordArray.init(H.slice(0));\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcut\n\t            var H = this._hash.words;\n\n\t            // Working variables\n\t            var a = H[0];\n\t            var b = H[1];\n\t            var c = H[2];\n\t            var d = H[3];\n\t            var e = H[4];\n\t            var f = H[5];\n\t            var g = H[6];\n\t            var h = H[7];\n\n\t            // Computation\n\t            for (var i = 0; i < 64; i++) {\n\t                if (i < 16) {\n\t                    W[i] = M[offset + i] | 0;\n\t                } else {\n\t                    var gamma0x = W[i - 15];\n\t                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^\n\t                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^\n\t                                   (gamma0x >>> 3);\n\n\t                    var gamma1x = W[i - 2];\n\t                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^\n\t                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^\n\t                                   (gamma1x >>> 10);\n\n\t                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n\t                }\n\n\t                var ch  = (e & f) ^ (~e & g);\n\t                var maj = (a & b) ^ (a & c) ^ (b & c);\n\n\t                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));\n\t                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));\n\n\t                var t1 = h + sigma1 + ch + K[i] + W[i];\n\t                var t2 = sigma0 + maj;\n\n\t                h = g;\n\t                g = f;\n\t                f = e;\n\t                e = (d + t1) | 0;\n\t                d = c;\n\t                c = b;\n\t                b = a;\n\t                a = (t1 + t2) | 0;\n\t            }\n\n\t            // Intermediate hash value\n\t            H[0] = (H[0] + a) | 0;\n\t            H[1] = (H[1] + b) | 0;\n\t            H[2] = (H[2] + c) | 0;\n\t            H[3] = (H[3] + d) | 0;\n\t            H[4] = (H[4] + e) | 0;\n\t            H[5] = (H[5] + f) | 0;\n\t            H[6] = (H[6] + g) | 0;\n\t            H[7] = (H[7] + h) | 0;\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n\t            data.sigBytes = dataWords.length * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Return final computed hash\n\t            return this._hash;\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\t            clone._hash = this._hash.clone();\n\n\t            return clone;\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA256('message');\n\t     *     var hash = CryptoJS.SHA256(wordArray);\n\t     */\n\t    C.SHA256 = Hasher._createHelper(SHA256);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA256(message, key);\n\t     */\n\t    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);\n\t}(Math));\n\n\n\treturn CryptoJS.SHA256;\n\n}));","'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst CURVE = {\n    a: 0n,\n    b: 7n,\n    P: 2n ** 256n - 2n ** 32n - 977n,\n    n: 2n ** 256n - 432420386565659656852420866394968145599n,\n    h: 1n,\n    Gx: 55066263022277343669578718895168534326250603453777594175500187360389116729240n,\n    Gy: 32670510020758816978083085130507043184471273380659243275938904335757337482424n,\n    beta: 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501een,\n};\nexports.CURVE = CURVE;\nconst PRIME_SIZE = 256;\nconst P_DIV4_1 = (CURVE.P + 1n) / 4n;\nfunction weistrass(x) {\n    const { a, b } = CURVE;\n    return mod(x ** 3n + a * x + b);\n}\nconst USE_ENDOMORPHISM = CURVE.a === 0n;\nclass JacobianPoint {\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    static fromAffine(p) {\n        if (!(p instanceof Point)) {\n            throw new TypeError('JacobianPoint#fromAffine: expected Point');\n        }\n        return new JacobianPoint(p.x, p.y, 1n);\n    }\n    static toAffineBatch(points) {\n        const toInv = invertBatch(points.map((p) => p.z));\n        return points.map((p, i) => p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n        return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);\n    }\n    equals(other) {\n        const a = this;\n        const b = other;\n        const az2 = mod(a.z * a.z);\n        const az3 = mod(a.z * az2);\n        const bz2 = mod(b.z * b.z);\n        const bz3 = mod(b.z * bz2);\n        return mod(a.x * bz2) === mod(az2 * b.x) && mod(a.y * bz3) === mod(az3 * b.y);\n    }\n    negate() {\n        return new JacobianPoint(this.x, mod(-this.y), this.z);\n    }\n    double() {\n        const X1 = this.x;\n        const Y1 = this.y;\n        const Z1 = this.z;\n        const A = X1 ** 2n;\n        const B = Y1 ** 2n;\n        const C = B ** 2n;\n        const D = 2n * ((X1 + B) ** 2n - A - C);\n        const E = 3n * A;\n        const F = E ** 2n;\n        const X3 = mod(F - 2n * D);\n        const Y3 = mod(E * (D - X3) - 8n * C);\n        const Z3 = mod(2n * Y1 * Z1);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    add(other) {\n        if (!(other instanceof JacobianPoint)) {\n            throw new TypeError('JacobianPoint#add: expected JacobianPoint');\n        }\n        const X1 = this.x;\n        const Y1 = this.y;\n        const Z1 = this.z;\n        const X2 = other.x;\n        const Y2 = other.y;\n        const Z2 = other.z;\n        if (X2 === 0n || Y2 === 0n)\n            return this;\n        if (X1 === 0n || Y1 === 0n)\n            return other;\n        const Z1Z1 = Z1 ** 2n;\n        const Z2Z2 = Z2 ** 2n;\n        const U1 = X1 * Z2Z2;\n        const U2 = X2 * Z1Z1;\n        const S1 = Y1 * Z2 * Z2Z2;\n        const S2 = Y2 * Z1 * Z1Z1;\n        const H = mod(U2 - U1);\n        const r = mod(S2 - S1);\n        if (H === 0n) {\n            if (r === 0n) {\n                return this.double();\n            }\n            else {\n                return JacobianPoint.ZERO;\n            }\n        }\n        const HH = mod(H ** 2n);\n        const HHH = mod(H * HH);\n        const V = U1 * HH;\n        const X3 = mod(r ** 2n - HHH - 2n * V);\n        const Y3 = mod(r * (V - X3) - S1 * HHH);\n        const Z3 = mod(Z1 * Z2 * H);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    multiplyUnsafe(scalar) {\n        if (typeof scalar !== 'number' && typeof scalar !== 'bigint') {\n            throw new TypeError('Point#multiply: expected number or bigint');\n        }\n        let n = mod(BigInt(scalar), CURVE.n);\n        if (n <= 0) {\n            throw new Error('Point#multiply: invalid scalar, expected positive integer');\n        }\n        if (!USE_ENDOMORPHISM) {\n            let p = JacobianPoint.ZERO;\n            let d = this;\n            while (n > 0n) {\n                if (n & 1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= 1n;\n            }\n            return p;\n        }\n        let [k1neg, k1, k2neg, k2] = splitScalarEndo(n);\n        let k1p = JacobianPoint.ZERO;\n        let k2p = JacobianPoint.ZERO;\n        let d = this;\n        while (k1 > 0n || k2 > 0n) {\n            if (k1 & 1n)\n                k1p = k1p.add(d);\n            if (k2 & 1n)\n                k2p = k2p.add(d);\n            d = d.double();\n            k1 >>= 1n;\n            k2 >>= 1n;\n        }\n        if (k1neg)\n            k1p = k1p.negate();\n        if (k2neg)\n            k2p = k2p.negate();\n        k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);\n        return k1p.add(k2p);\n    }\n    precomputeWindow(W) {\n        const windows = USE_ENDOMORPHISM ? 128 / W + 2 : 256 / W + 1;\n        let points = [];\n        let p = this;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            for (let i = 1; i < 2 ** (W - 1); i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    wNAF(n, affinePoint) {\n        if (!affinePoint && this.equals(JacobianPoint.BASE))\n            affinePoint = Point.BASE;\n        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;\n        if (256 % W) {\n            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n        }\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n        if (!precomputes) {\n            precomputes = this.precomputeWindow(W);\n            if (affinePoint && W !== 1) {\n                precomputes = JacobianPoint.normalizeZ(precomputes);\n                pointPrecomputes.set(affinePoint, precomputes);\n            }\n        }\n        let p = JacobianPoint.ZERO;\n        let f = JacobianPoint.ZERO;\n        const windows = USE_ENDOMORPHISM ? 128 / W + 2 : 256 / W + 1;\n        const windowSize = 2 ** (W - 1);\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for (let window = 0; window < windows; window++) {\n            const offset = window * windowSize;\n            let wbits = Number(n & mask);\n            n >>= shiftBy;\n            if (wbits > windowSize) {\n                wbits -= maxNumber;\n                n += 1n;\n            }\n            if (wbits === 0) {\n                f = f.add(window % 2 ? precomputes[offset].negate() : precomputes[offset]);\n            }\n            else {\n                const cached = precomputes[offset + Math.abs(wbits) - 1];\n                p = p.add(wbits < 0 ? cached.negate() : cached);\n            }\n        }\n        return [p, f];\n    }\n    multiply(scalar, affinePoint) {\n        if (typeof scalar !== 'number' && typeof scalar !== 'bigint') {\n            throw new TypeError('Point#multiply: expected number or bigint');\n        }\n        let n = mod(BigInt(scalar), CURVE.n);\n        if (n <= 0) {\n            throw new Error('Point#multiply: invalid scalar, expected positive integer');\n        }\n        let point;\n        let fake;\n        if (USE_ENDOMORPHISM) {\n            const [k1neg, k1, k2neg, k2] = splitScalarEndo(n);\n            let k1p, k2p, f1p, f2p;\n            [k1p, f1p] = this.wNAF(k1, affinePoint);\n            [k2p, f2p] = this.wNAF(k2, affinePoint);\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);\n            [point, fake] = [k1p.add(k2p), f1p.add(f2p)];\n        }\n        else {\n            [point, fake] = this.wNAF(n, affinePoint);\n        }\n        return JacobianPoint.normalizeZ([point, fake])[0];\n    }\n    toAffine(invZ = invert(this.z)) {\n        const invZ2 = invZ ** 2n;\n        const x = mod(this.x * invZ2);\n        const y = mod(this.y * invZ2 * invZ);\n        return new Point(x, y);\n    }\n}\nJacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, 1n);\nJacobianPoint.ZERO = new JacobianPoint(0n, 1n, 0n);\nconst pointPrecomputes = new WeakMap();\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n    }\n    static fromX(bytes) {\n        const x = bytesToNumber(bytes);\n        const sqrY = weistrass(x);\n        let y = powMod(sqrY, P_DIV4_1, CURVE.P);\n        const isYOdd = (y & 1n) === 1n;\n        if (isYOdd)\n            y = mod(-y);\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromCompressedHex(bytes) {\n        if (bytes.length !== 33) {\n            throw new TypeError(`Point.fromHex: compressed expects 33 bytes, not ${bytes.length * 2}`);\n        }\n        const x = bytesToNumber(bytes.slice(1));\n        const sqrY = weistrass(x);\n        let y = powMod(sqrY, P_DIV4_1, CURVE.P);\n        const isFirstByteOdd = (bytes[0] & 1) === 1;\n        const isYOdd = (y & 1n) === 1n;\n        if (isFirstByteOdd !== isYOdd)\n            y = mod(-y);\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromUncompressedHex(bytes) {\n        if (bytes.length !== 65) {\n            throw new TypeError(`Point.fromHex: uncompressed expects 65 bytes, not ${bytes.length * 2}`);\n        }\n        const x = bytesToNumber(bytes.slice(1, 33));\n        const y = bytesToNumber(bytes.slice(33));\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromHex(hex) {\n        const bytes = hex instanceof Uint8Array ? hex : hexToBytes(hex);\n        if (bytes.length === 32)\n            return this.fromX(bytes);\n        const header = bytes[0];\n        if (header === 0x02 || header === 0x03)\n            return this.fromCompressedHex(bytes);\n        if (header === 0x04)\n            return this.fromUncompressedHex(bytes);\n        throw new TypeError('Point.fromHex: received invalid point');\n    }\n    static fromPrivateKey(privateKey) {\n        return Point.BASE.multiply(normalizePrivateKey(privateKey));\n    }\n    static fromSignature(msgHash, signature, recovery) {\n        const sign = normalizeSignature(signature);\n        const { r, s } = sign;\n        if (r === 0n || s === 0n)\n            return;\n        const rinv = invert(r, CURVE.n);\n        const h = typeof msgHash === 'string' ? hexToNumber(msgHash) : bytesToNumber(msgHash);\n        const P_ = Point.fromHex(`0${2 + (recovery & 1)}${pad64(r)}`);\n        const sP = JacobianPoint.fromAffine(P_).multiplyUnsafe(s);\n        const hG = JacobianPoint.BASE.multiply(h).negate();\n        const Q = sP.add(hG).multiplyUnsafe(rinv);\n        const point = Q.toAffine();\n        point.assertValidity();\n        return point;\n    }\n    toRawBytes(isCompressed = false) {\n        return hexToBytes(this.toHex(isCompressed));\n    }\n    toHex(isCompressed = false) {\n        const x = pad64(this.x);\n        if (isCompressed) {\n            return `${this.y & 1n ? '03' : '02'}${x}`;\n        }\n        else {\n            return `04${x}${pad64(this.y)}`;\n        }\n    }\n    toHexX() {\n        return this.toHex(true).slice(2);\n    }\n    toRawX() {\n        return this.toRawBytes(true).slice(1);\n    }\n    assertValidity() {\n        const { x, y } = this;\n        if (x === 0n || y === 0n || x >= CURVE.P || y >= CURVE.P) {\n            throw new TypeError('Point is not on elliptic curve');\n        }\n        const left = mod(y * y);\n        const right = weistrass(x);\n        const valid = (left - right) % CURVE.P === 0n;\n        if (!valid)\n            throw new TypeError('Point is not on elliptic curve');\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n        return new Point(this.x, mod(-this.y));\n    }\n    double() {\n        return JacobianPoint.fromAffine(this).double().toAffine();\n    }\n    add(other) {\n        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiply(scalar) {\n        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n}\nexports.Point = Point;\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(0n, 0n);\nfunction sliceDer(s) {\n    return parseInt(s[0], 16) >= 8 ? '00' + s : s;\n}\nclass Signature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n    }\n    static fromHex(hex) {\n        const str = hex instanceof Uint8Array ? bytesToHex(hex) : hex;\n        if (typeof str !== 'string')\n            throw new TypeError({}.toString.call(hex));\n        const check1 = str.slice(0, 2);\n        const length = parseByte(str.slice(2, 4));\n        const check2 = str.slice(4, 6);\n        if (check1 !== '30' || length !== str.length - 4 || check2 !== '02') {\n            throw new Error('Signature.fromHex: Invalid signature');\n        }\n        const rLen = parseByte(str.slice(6, 8));\n        const rEnd = 8 + rLen;\n        const r = hexToNumber(str.slice(8, rEnd));\n        const check3 = str.slice(rEnd, rEnd + 2);\n        if (check3 !== '02') {\n            throw new Error('SignResult.fromHex: Invalid signature');\n        }\n        const sLen = parseByte(str.slice(rEnd + 2, rEnd + 4));\n        const sStart = rEnd + 4;\n        const s = hexToNumber(str.slice(sStart, sStart + sLen));\n        return new Signature(r, s);\n    }\n    toRawBytes(isCompressed = false) {\n        return hexToBytes(this.toHex(isCompressed));\n    }\n    toHex(isCompressed = false) {\n        const sHex = sliceDer(numberToHex(this.s));\n        if (isCompressed)\n            return sHex;\n        const rHex = sliceDer(numberToHex(this.r));\n        const rLen = numberToHex(rHex.length / 2);\n        const sLen = numberToHex(sHex.length / 2);\n        const length = numberToHex(rHex.length / 2 + sHex.length / 2 + 4);\n        return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;\n    }\n}\nexports.Signature = Signature;\nexports.SignResult = Signature;\nfunction concatBytes(...arrays) {\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nfunction bytesToHex(uint8a) {\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += uint8a[i].toString(16).padStart(2, '0');\n    }\n    return hex;\n}\nfunction pad64(num) {\n    return num.toString(16).padStart(64, '0');\n}\nfunction pad32b(num) {\n    return hexToBytes(pad64(num));\n}\nfunction numberToHex(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToNumber: expected string, got ' + typeof hex);\n    }\n    return BigInt(`0x${hex}`);\n}\nfunction hexToBytes(hex) {\n    hex = hex.length & 1 ? `0${hex}` : hex;\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        let j = i * 2;\n        array[i] = Number.parseInt(hex.slice(j, j + 2), 16);\n    }\n    return array;\n}\nfunction bytesToNumber(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction parseByte(str) {\n    return Number.parseInt(str, 16) * 2;\n}\nfunction mod(a, b = CURVE.P) {\n    const result = a % b;\n    return result >= 0 ? result : b + result;\n}\nfunction powMod(x, power, order) {\n    let res = 1n;\n    while (power > 0) {\n        if (power & 1n) {\n            res = mod(res * x, order);\n        }\n        power >>= 1n;\n        x = mod(x * x, order);\n    }\n    return res;\n}\nfunction egcd(a, b) {\n    let [x, y, u, v] = [0n, 1n, 1n, 0n];\n    while (a !== 0n) {\n        let q = b / a;\n        let r = b % a;\n        let m = x - u * q;\n        let n = y - v * q;\n        [b, a] = [a, r];\n        [x, y] = [u, v];\n        [u, v] = [m, n];\n    }\n    const gcd = b;\n    return [gcd, x, y];\n}\nfunction invert(number, modulo = CURVE.P) {\n    if (number === 0n || modulo <= 0n) {\n        throw new Error('invert: expected positive integers');\n    }\n    const [gcd, x] = egcd(mod(number, modulo), modulo);\n    if (gcd !== 1n) {\n        throw new Error('invert: does not exist');\n    }\n    return mod(x, modulo);\n}\nfunction invertBatch(nums, n = CURVE.P) {\n    const len = nums.length;\n    const scratch = new Array(len);\n    let acc = 1n;\n    for (let i = 0; i < len; i++) {\n        if (nums[i] === 0n)\n            continue;\n        scratch[i] = acc;\n        acc = mod(acc * nums[i], n);\n    }\n    acc = invert(acc, n);\n    for (let i = len - 1; i >= 0; i--) {\n        if (nums[i] === 0n)\n            continue;\n        let tmp = mod(acc * nums[i], n);\n        nums[i] = mod(acc * scratch[i], n);\n        acc = tmp;\n    }\n    return nums;\n}\nfunction splitScalarEndo(k) {\n    const { n } = CURVE;\n    const a1 = 0x3086d221a7d46bcde86c90e49284eb15n;\n    const b1 = -0xe4437ed6010e88286f547fa90abfe4c3n;\n    const a2 = 0x114ca50f7a8e2f3f657c1108d9d44cfd8n;\n    const b2 = a1;\n    const c1 = (b2 * k) / n;\n    const c2 = (-b1 * k) / n;\n    const k1 = k - c1 * a1 - c2 * a2;\n    const k2 = -c1 * b1 - c2 * b2;\n    const k1neg = k1 < 0;\n    const k2neg = k2 < 0;\n    return [k1neg, k1neg ? -k1 : k1, k2neg, k2neg ? -k2 : k2];\n}\nfunction truncateHash(hash) {\n    hash = typeof hash === 'string' ? hash : bytesToHex(hash);\n    let msg = hexToNumber(hash || '0');\n    const delta = (hash.length / 2) * 8 - PRIME_SIZE;\n    if (delta > 0) {\n        msg = msg >> BigInt(delta);\n    }\n    if (msg >= CURVE.n) {\n        msg -= CURVE.n;\n    }\n    return msg;\n}\nasync function getQRSrfc6979(msgHash, privateKey) {\n    const num = typeof msgHash === 'string' ? hexToNumber(msgHash) : bytesToNumber(msgHash);\n    const h1 = pad32b(num);\n    const x = pad32b(privateKey);\n    const h1n = bytesToNumber(h1);\n    let v = new Uint8Array(32).fill(1);\n    let k = new Uint8Array(32).fill(0);\n    const b0 = Uint8Array.from([0x00]);\n    const b1 = Uint8Array.from([0x01]);\n    k = await exports.utils.hmacSha256(k, v, b0, x, h1);\n    v = await exports.utils.hmacSha256(k, v);\n    k = await exports.utils.hmacSha256(k, v, b1, x, h1);\n    v = await exports.utils.hmacSha256(k, v);\n    for (let i = 0; i < 1000; i++) {\n        v = await exports.utils.hmacSha256(k, v);\n        const T = bytesToNumber(v);\n        let qrs;\n        if (isValidPrivateKey(T) && (qrs = calcQRSFromK(T, h1n, privateKey))) {\n            return qrs;\n        }\n        k = await exports.utils.hmacSha256(k, v, b0);\n        v = await exports.utils.hmacSha256(k, v);\n    }\n    throw new TypeError('secp256k1: Tried 1,000 k values for sign(), all were invalid');\n}\nfunction isValidPrivateKey(privateKey) {\n    return 0 < privateKey && privateKey < CURVE.n;\n}\nfunction calcQRSFromK(k, msg, priv) {\n    const max = CURVE.n;\n    const q = Point.BASE.multiply(k);\n    const r = mod(q.x, max);\n    const s = mod(invert(k, max) * (msg + r * priv), max);\n    if (r === 0n || s === 0n)\n        return;\n    return [q, r, s];\n}\nfunction normalizePrivateKey(privateKey) {\n    if (!privateKey)\n        throw new Error(`Expected receive valid private key, not \"${privateKey}\"`);\n    let key;\n    if (privateKey instanceof Uint8Array) {\n        key = bytesToNumber(privateKey);\n    }\n    else if (typeof privateKey === 'string') {\n        key = hexToNumber(privateKey);\n    }\n    else {\n        key = BigInt(privateKey);\n    }\n    return key;\n}\nfunction normalizePublicKey(publicKey) {\n    return publicKey instanceof Point ? publicKey : Point.fromHex(publicKey);\n}\nfunction normalizeSignature(signature) {\n    return signature instanceof Signature ? signature : Signature.fromHex(signature);\n}\nfunction getPublicKey(privateKey, isCompressed = false) {\n    const point = Point.fromPrivateKey(privateKey);\n    if (typeof privateKey === 'string') {\n        return point.toHex(isCompressed);\n    }\n    return point.toRawBytes(isCompressed);\n}\nexports.getPublicKey = getPublicKey;\nfunction recoverPublicKey(msgHash, signature, recovery) {\n    const point = Point.fromSignature(msgHash, signature, recovery);\n    if (!point)\n        return;\n    return typeof msgHash === 'string' ? point.toHex() : point.toRawBytes();\n}\nexports.recoverPublicKey = recoverPublicKey;\nfunction isPub(item) {\n    const arr = item instanceof Uint8Array;\n    const str = typeof item === 'string';\n    const len = (arr || str) && item.length;\n    if (arr)\n        return len === 33 || len === 65;\n    if (str)\n        return len === 66 || len === 130;\n    if (item instanceof Point)\n        return true;\n    return false;\n}\nfunction getSharedSecret(privateA, publicB, isCompressed = false) {\n    if (isPub(privateA) && !isPub(publicB)) {\n        [privateA, publicB] = [publicB, privateA];\n    }\n    else if (!isPub(publicB)) {\n        throw new Error('Received invalid keys');\n    }\n    const b = publicB instanceof Point ? publicB : Point.fromHex(publicB);\n    b.assertValidity();\n    const shared = b.multiply(normalizePrivateKey(privateA));\n    return typeof privateA === 'string'\n        ? shared.toHex(isCompressed)\n        : shared.toRawBytes(isCompressed);\n}\nexports.getSharedSecret = getSharedSecret;\nasync function sign(msgHash, privateKey, { recovered, canonical } = {}) {\n    if (msgHash == null)\n        throw new Error(`Expected valid msgHash, not \"${msgHash}\"`);\n    const priv = normalizePrivateKey(privateKey);\n    const [q, r, s] = await getQRSrfc6979(msgHash, priv);\n    let recovery = (q.x === r ? 0 : 2) | Number(q.y & 1n);\n    let adjustedS = s;\n    const HIGH_NUMBER = CURVE.n >> 1n;\n    if (s > HIGH_NUMBER && canonical) {\n        adjustedS = CURVE.n - s;\n        recovery ^= 1;\n    }\n    const sig = new Signature(r, adjustedS);\n    const hashed = typeof msgHash === 'string' ? sig.toHex() : sig.toRawBytes();\n    return recovered ? [hashed, recovery] : hashed;\n}\nexports.sign = sign;\nfunction verify(signature, msgHash, publicKey) {\n    const h = truncateHash(msgHash);\n    const { r, s } = normalizeSignature(signature);\n    const pubKey = JacobianPoint.fromAffine(normalizePublicKey(publicKey));\n    const s1 = invert(s, CURVE.n);\n    const Ghs1 = JacobianPoint.BASE.multiply(mod(h * s1, CURVE.n));\n    const Prs1 = pubKey.multiplyUnsafe(mod(r * s1, CURVE.n));\n    const res = Ghs1.add(Prs1).toAffine();\n    return res.x === r;\n}\nexports.verify = verify;\nasync function taggedHash(tag, ...messages) {\n    const tagB = new Uint8Array(tag.split('').map((c) => c.charCodeAt(0)));\n    const tagH = await exports.utils.sha256(tagB);\n    const h = await exports.utils.sha256(concatBytes(tagH, tagH, ...messages));\n    return bytesToNumber(h);\n}\nasync function createChallenge(x, P, message) {\n    const rx = pad32b(x);\n    const t = await taggedHash('BIP0340/challenge', rx, P.toRawX(), message);\n    return mod(t, CURVE.n);\n}\nfunction hasEvenY(point) {\n    return mod(point.y, 2n) === 0n;\n}\nclass SchnorrSignature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        if (r === 0n || s === 0n || r >= CURVE.P || s >= CURVE.n)\n            throw new Error('Invalid signature');\n    }\n    static fromHex(hex) {\n        const bytes = hex instanceof Uint8Array ? hex : hexToBytes(hex);\n        if (bytes.length !== 64) {\n            throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);\n        }\n        const r = bytesToNumber(bytes.slice(0, 32));\n        const s = bytesToNumber(bytes.slice(32));\n        return new SchnorrSignature(r, s);\n    }\n    toHex() {\n        return pad64(this.r) + pad64(this.s);\n    }\n    toRawBytes() {\n        return hexToBytes(this.toHex());\n    }\n}\nfunction schnorrGetPublicKey(privateKey) {\n    const P = Point.fromPrivateKey(privateKey);\n    return typeof privateKey === 'string' ? P.toHexX() : P.toRawX();\n}\nasync function schnorrSign(msgHash, privateKey, auxRand = exports.utils.randomPrivateKey()) {\n    if (msgHash == null)\n        throw new TypeError(`Expected valid message, not \"${msgHash}\"`);\n    if (!privateKey)\n        privateKey = 0n;\n    const { n } = CURVE;\n    const m = typeof msgHash === 'string' ? hexToBytes(msgHash) : msgHash;\n    const d0 = normalizePrivateKey(privateKey);\n    if (!(0 < d0 && d0 < n))\n        throw new Error('Invalid private key');\n    const rand = typeof auxRand === 'string' ? hexToBytes(auxRand) : auxRand;\n    if (rand.length !== 32)\n        throw new TypeError('Expected 32 bytes of aux randomness');\n    const P = Point.fromPrivateKey(d0);\n    const d = hasEvenY(P) ? d0 : n - d0;\n    const t0h = await taggedHash('BIP0340/aux', rand);\n    const t = d ^ t0h;\n    const k0h = await taggedHash('BIP0340/nonce', pad32b(t), P.toRawX(), m);\n    const k0 = mod(k0h, n);\n    if (k0 === 0n)\n        throw new Error('Creation of signature failed. k is zero');\n    const R = Point.fromPrivateKey(k0);\n    const k = hasEvenY(R) ? k0 : n - k0;\n    const e = await createChallenge(R.x, P, m);\n    const sig = new SchnorrSignature(R.x, mod(k + e * d, n));\n    const isValid = await schnorrVerify(sig.toRawBytes(), m, P.toRawX());\n    if (!isValid)\n        throw new Error('Invalid signature produced');\n    return typeof msgHash === 'string' ? sig.toHex() : sig.toRawBytes();\n}\nasync function schnorrVerify(signature, msgHash, publicKey) {\n    const sig = signature instanceof SchnorrSignature ? signature : SchnorrSignature.fromHex(signature);\n    const m = typeof msgHash === 'string' ? hexToBytes(msgHash) : msgHash;\n    const P = normalizePublicKey(publicKey);\n    const e = await createChallenge(sig.r, P, m);\n    const sG = Point.fromPrivateKey(sig.s);\n    const eP = P.multiply(e);\n    const R = sG.subtract(eP);\n    if (R.equals(Point.BASE) || !hasEvenY(R) || R.x !== sig.r)\n        return false;\n    return true;\n}\nexports.schnorr = {\n    Signature: SchnorrSignature,\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n};\nPoint.BASE._setWindowSize(8);\nexports.utils = {\n    isValidPrivateKey(privateKey) {\n        return isValidPrivateKey(normalizePrivateKey(privateKey));\n    },\n    randomPrivateKey: (bytesLength = 32) => {\n        if (typeof window == 'object' && 'crypto' in window) {\n            return window.crypto.getRandomValues(new Uint8Array(bytesLength));\n        }\n        else if (typeof process === 'object' && 'node' in process.versions) {\n            const { randomBytes } = require('crypto');\n            return new Uint8Array(randomBytes(bytesLength).buffer);\n        }\n        else {\n            throw new Error(\"The environment doesn't have randomBytes function\");\n        }\n    },\n    sha256: async (message) => {\n        if (typeof window == 'object' && 'crypto' in window) {\n            const buffer = await window.crypto.subtle.digest('SHA-256', message.buffer);\n            return new Uint8Array(buffer);\n        }\n        else if (typeof process === 'object' && 'node' in process.versions) {\n            const { createHash } = require('crypto');\n            return Uint8Array.from(createHash('sha256').update(message).digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have sha256 function\");\n        }\n    },\n    hmacSha256: async (key, ...messages) => {\n        if (typeof window == 'object' && 'crypto' in window) {\n            const ckey = await window.crypto.subtle.importKey('raw', key, { name: 'HMAC', hash: { name: 'SHA-256' } }, false, ['sign']);\n            const message = concatBytes(...messages);\n            const buffer = await window.crypto.subtle.sign('HMAC', ckey, message);\n            return new Uint8Array(buffer);\n        }\n        else if (typeof process === 'object' && 'node' in process.versions) {\n            const { createHmac, randomBytes } = require('crypto');\n            const hash = createHmac('sha256', key);\n            for (let message of messages) {\n                hash.update(message);\n            }\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have hmac-sha256 function\");\n        }\n    },\n    precompute(windowSize = 8, point = Point.BASE) {\n        const cached = point === Point.BASE ? point : new Point(point.x, point.y);\n        cached._setWindowSize(windowSize);\n        cached.multiply(3n);\n        return cached;\n    },\n};\n","module.exports = require(\"crypto\");;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(905);\n"],"sourceRoot":""}