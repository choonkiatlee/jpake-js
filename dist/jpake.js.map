{"version":3,"sources":["webpack://jpake/webpack/universalModuleDefinition","webpack://jpake/./src/jpake.ts","webpack://jpake/./src/utils.ts","webpack://jpake/./node_modules/crypto-js/core.js","webpack://jpake/./node_modules/crypto-js/sha256.js","webpack://jpake/./node_modules/noble-secp256k1/index.js","webpack://jpake/webpack/bootstrap","webpack://jpake/webpack/startup","webpack://jpake/webpack/runtime/global"],"names":["root","factory","exports","module","define","amd","this","ZEROPOINT","secp","Point","CURVE","Gx","Gy","secret","hashFn","SHA256Hash","s","mod","BigInt","n","x1","randBetween","x2","G","x1G","multiply","x2G","x","xG","v","t","equals","chal","asPad64HexString","y","c","r","tx","ty","add","pubVar","x1Gx","x1Gy","x2Gx","x2Gy","JSON","stringify","jsonStringFromB","otherPubVars","parse","otherx1G","otherx2G","x2s","A","Ax","Ay","otherA","Ka","subtract","getRandomBits","bitLength","randBytes","byteLength","uint8Buf","Uint8Array","window","crypto","getRandomValues","process","versions","randomBytes","buffer","Error","getRandomBytes","Math","ceil","bitLengthMod8","fromBuffer","buf","ret","i","values","bi","min","max","RangeError","interval","bitLen","a","bits","rnd","add0x","pad64HexString","toString","padStart","toHash","CryptoJS","undefined","msCrypto","g","err","cryptoSecureRandomInt","Uint32Array","readInt32LE","create","Object","F","obj","subtype","prototype","C","C_lib","lib","Base","extend","overrides","mixIn","hasOwnProperty","init","$super","apply","arguments","instance","properties","propertyName","clone","WordArray","words","sigBytes","length","encoder","Hex","concat","wordArray","thisWords","thatWords","thisSigBytes","thatSigBytes","clamp","thatByte","call","slice","random","nBytes","push","C_enc","enc","hexChars","bite","join","hexStr","hexStrLength","parseInt","substr","Latin1","latin1Chars","String","fromCharCode","latin1Str","latin1StrLength","charCodeAt","Utf8","decodeURIComponent","escape","e","utf8Str","unescape","encodeURIComponent","BufferedBlockAlgorithm","reset","_data","_nDataBytes","_append","data","_process","doFlush","processedWords","dataWords","dataSigBytes","blockSize","nBlocksReady","nWordsReady","_minBufferSize","nBytesReady","offset","_doProcessBlock","splice","C_algo","Hasher","cfg","_doReset","update","messageUpdate","finalize","_doFinalize","_createHelper","hasher","message","_createHmacHelper","key","HMAC","algo","H","K","isPrime","sqrtN","sqrt","factor","getFractionalBits","nPrime","pow","W","SHA256","_hash","M","b","d","f","h","gamma0x","gamma0","gamma1x","gamma1","maj","sigma0","t1","nBitsTotal","nBitsLeft","floor","HmacSHA256","defineProperty","value","P","beta","P_DIV4_1","weistrass","USE_ENDOMORPHISM","JacobianPoint","z","p","TypeError","points","toInv","nums","len","scratch","Array","acc","invert","tmp","invertBatch","map","toAffine","toAffineBatch","fromAffine","other","az2","az3","bz2","bz3","X1","Y1","Z1","B","D","E","X3","Y3","Z3","X2","Y2","Z2","Z1Z1","Z2Z2","U1","S1","S2","double","ZERO","HH","HHH","V","scalar","k1neg","k1","k2neg","k2","splitScalarEndo","k1p","k2p","negate","windows","base","affinePoint","BASE","_WINDOW_SIZE","precomputes","pointPrecomputes","get","precomputeWindow","normalizeZ","set","windowSize","mask","maxNumber","shiftBy","wbits","Number","cached","abs","point","fake","f1p","f2p","wNAF","invZ","invZ2","WeakMap","delete","bytes","bytesToNumber","powMod","assertValidity","hex","hexToBytes","fromX","header","fromCompressedHex","fromUncompressedHex","privateKey","normalizePrivateKey","msgHash","signature","recovery","sign","normalizeSignature","rinv","hexToNumber","P_","fromHex","pad64","sP","multiplyUnsafe","hG","isCompressed","toHex","toRawBytes","sliceDer","Signature","str","bytesToHex","check1","parseByte","check2","rEnd","sLen","sStart","sHex","numberToHex","rHex","rLen","concatBytes","arrays","reduce","arr","result","pad","uint8a","num","pad32b","array","j","power","order","res","number","modulo","gcd","u","q","m","egcd","k","a1","b1","c1","c2","isValidPrivateKey","calcQRSFromK","msg","priv","normalizePublicKey","publicKey","isPub","item","async","taggedHash","tag","messages","tagB","split","tagH","utils","sha256","createChallenge","rx","toRawX","hasEvenY","SignResult","getPublicKey","fromPrivateKey","recoverPublicKey","fromSignature","getSharedSecret","privateA","publicB","shared","recovered","canonical","h1","h1n","fill","b0","from","hmacSha256","T","qrs","getQRSrfc6979","adjustedS","sig","hashed","verify","hash","delta","truncateHash","pubKey","s1","Ghs1","Prs1","SchnorrSignature","schnorrVerify","sG","eP","R","schnorr","toHexX","auxRand","randomPrivateKey","d0","rand","k0","_setWindowSize","bytesLength","subtle","digest","createHash","ckey","importKey","name","createHmac","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__","globalThis","Function"],"mappings":"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","file":"jpake.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"jpake\"] = factory();\n\telse\n\t\troot[\"jpake\"] = factory();\n})(this, function() {\nreturn ","import * as secp from \"noble-secp256k1\";\r\nimport {randBetween, asPad64HexString, mod, SHA256Hash} from './utils'\r\n\r\n// see: https://billatnapier.medium.com/password-juggling-in-discrete-logs-and-elliptic-curves-a82d5926d26d\r\n// https://asecuritysite.com/encryption/jpake2\r\nconst ZEROPOINT = new secp.Point(0n, 0n)\r\nconst BASEPOINT = new secp.Point(secp.CURVE.Gx, secp.CURVE.Gy)\r\n\r\nexport class JPake {\r\n    \r\n    // Private Variables\r\n    private x1:  bigint\r\n    private x2:  bigint\r\n    private s:   bigint\r\n\r\n    // Public Variables\r\n    x1G: secp.Point\r\n    x2G: secp.Point\r\n\r\n    // Received Variables / cached variables\r\n    x2s: bigint\r\n    otherx2G: secp.Point\r\n    otherV: secp.Point\r\n    hashFn: (str: string) => string\r\n\r\n    constructor(secret: string, hashFn: (str: string) => string = SHA256Hash) { \r\n        this.hashFn = hashFn\r\n\r\n        this.s = mod( BigInt(\"0x\" + this.hashFn(secret)), secp.CURVE.n )\r\n        this.x1 = randBetween(0n, secp.CURVE.n - 1n)\r\n        this.x2 = randBetween(0n, secp.CURVE.n - 1n)\r\n\r\n        const G = new secp.Point(secp.CURVE.Gx, secp.CURVE.Gy );\r\n        this.x1G = G.multiply(this.x1)\r\n        this.x2G = G.multiply(this.x2)              \r\n    }\r\n\r\n    // ZKP checks not implemented into protocol yet.\r\n    computeZKP(x: bigint, G: secp.Point, xG: secp.Point = ZEROPOINT) : object{\r\n        // Computes a ZKP for x on curve G. We use the Fiat-Shamir heuristic:\r\n        // https://en.wikipedia.org/wiki/Fiat%E2%80%93Shamir_heuristic\r\n        // i.e. prove that we know x such that y = xG\r\n\r\n        // 1. Pick a random v \\in Z_q* and compute t = vG\r\n        const v = randBetween(0n, secp.CURVE.n - 1n)\r\n        const t = G.multiply(v)\r\n\r\n        // 2. Compute c = H(g, y, t) where H() is a cryptographic has fn\r\n        xG = (xG.equals(ZEROPOINT) ? G.multiply(x) : xG) // Calculate xG if not provided\r\n        const chal = asPad64HexString(G.x) + asPad64HexString(G.y) + asPad64HexString(t.x) + asPad64HexString(t.y) + asPad64HexString(xG.x) + asPad64HexString(xG.y)\r\n        const c = BigInt(\"0x\"+this.hashFn(chal))\r\n\r\n        // 3. Compute r = v - cx\r\n        const r = mod((v-c*x), secp.CURVE.n - 1n)\r\n\r\n        // The resulting proof is the pair (t, r).\r\n        // you can use this to verify the pair by\r\n        // calculating c = H(g, y, t) and checking if t == rG * cy.\r\n        // Here, we send over c for simplicity.\r\n        return {\r\n            tx: asPad64HexString(t.x),\r\n            ty: asPad64HexString(t.y),\r\n            r: asPad64HexString(r),\r\n            c: asPad64HexString(c),\r\n        }\r\n    }\r\n\r\n    checkZKP(tx: bigint, ty: bigint, r: bigint, c: bigint, G: secp.Point, y: secp.Point): boolean {\r\n        var Vcheck = G.multiply(r).add(y.multiply(c))\r\n        return Vcheck.equals(new secp.Point(tx, ty))\r\n    }\r\n\r\n    Round1Message(): string{\r\n        var pubVar = {\r\n            x1Gx: asPad64HexString(this.x1G.x),\r\n            x1Gy: asPad64HexString(this.x1G.y),\r\n            x2Gx: asPad64HexString(this.x2G.x),\r\n            x2Gy: asPad64HexString(this.x2G.y),\r\n        }\r\n        return JSON.stringify(pubVar);\r\n    }\r\n\r\n    Round2Message(jsonStringFromB: string): string{\r\n        // In Round 1, we receive x1G and x2G from Bob, and possibly knowledge proofs for x1 and x2\r\n        const otherPubVars = JSON.parse(jsonStringFromB)\r\n        const otherx1G = new secp.Point(BigInt(otherPubVars.x1Gx), BigInt(otherPubVars.x1Gy)) // also x3G and x4G from Bob if you are following the paper\r\n        const otherx2G = new secp.Point(BigInt(otherPubVars.x2Gx), BigInt(otherPubVars.x2Gy))\r\n        \r\n        // These are variables which can be cached for other steps \r\n        this.otherx2G = otherx2G\r\n        this.x2s = this.x2 * this.s\r\n\r\n        // A = (G1 + G3 + G4) x [x2*s]\r\n        var A = this.x1G.add(otherx1G).add(otherx2G)\r\n        A = A.multiply(this.x2s)\r\n\r\n        return JSON.stringify({\r\n            Ax: asPad64HexString(A.x),\r\n            Ay: asPad64HexString(A.y)\r\n        })\r\n    }\r\n\r\n    computeSharedKey(jsonStringFromB: string) : string {\r\n        const otherA = JSON.parse(jsonStringFromB)\r\n        const B = new secp.Point(BigInt(otherA.Ax), BigInt(otherA.Ay))\r\n\r\n        // Ka = (B - (G4 x [x2*s])) x [x2]\r\n        const Ka = B.subtract(this.otherx2G.multiply(this.x2s)).multiply(this.x2)\r\n        const sharedKey = this.hashFn(asPad64HexString(Ka.x))\r\n        return sharedKey\r\n    }\r\n}\r\n","import sha256  from 'crypto-js/sha256'\r\n\r\n\r\n/* HELPER FUNCTIONS */\r\nfunction modNum (x: number, n: number): number {\r\n    return ((x % n) + n) % n\r\n}\r\n\r\nexport function mod (x: bigint, n: bigint): bigint {\r\n    return ((x % n) + n) % n\r\n}\r\n  \r\nfunction getRandomBytes (byteLength: number): Uint8Array {\r\n    const uint8Buf = new Uint8Array(byteLength)\r\n    if (typeof window == 'object' && 'crypto' in window) {\r\n        return window.crypto.getRandomValues(uint8Buf);\r\n    }\r\n    else if (typeof process === 'object' && 'node' in process.versions) {\r\n        const { randomBytes } = require('crypto');\r\n        return new Uint8Array(randomBytes(byteLength).buffer);\r\n    }\r\n    else {\r\n        throw new Error(\"The environment doesn't have randomBytes function\");\r\n    }\r\n}\r\n\r\nfunction getRandomBits (bitLength: number): Uint8Array {\r\n    const byteLength = Math.ceil(bitLength / 8) \r\n    const randBytes = getRandomBytes(byteLength)\r\n\r\n    const bitLengthMod8 = modNum(bitLength, 8)\r\n    if (bitLengthMod8) {\r\n        // randBytes[0] is the MSByte\r\n        // Fill the MSByte with leading zeros to produce the correct\r\n        // bit length\r\n        randBytes[0] = randBytes[0] & (2 ** bitLengthMod8 - 1)\r\n    }\r\n    return randBytes\r\n}\r\n\r\nexport function fromBuffer (buf: Uint8Array) {\r\n    let ret = 0n\r\n    for (const i of buf.values()) {\r\n        const bi = BigInt(i)\r\n        ret = (ret << BigInt(8)) + bi\r\n    }\r\n    return ret\r\n}\r\n\r\nfunction bitLength (a: number|bigint) {\r\n    a = BigInt(a)\r\n    if (a === 1n) { return 1 }\r\n    let bits = 1\r\n    do {\r\n        bits++\r\n    } while ((a >>= 1n) > 1n)\r\n    return bits\r\n}\r\n\r\nexport function randBetween (min: bigint, max: bigint): bigint {\r\n    if (max <= 0n || min < 0n || max <= min) throw new RangeError('Arguments MUST be: max > 0 && min >=0 && max > min')\r\n    const interval = max - min\r\n    const bitLen = bitLength(interval)\r\n    let rnd\r\n    do {\r\n      const buf = getRandomBits(bitLen)\r\n      rnd = fromBuffer(buf)\r\n    } while (rnd > interval)\r\n    const randnum = rnd + min\r\n    return randnum\r\n}\r\n\r\nexport function asPad64HexString(x: bigint, add0x: boolean = true): string {\r\n    const pad64HexString = x.toString(16).padStart(64, '0')\r\n    return add0x ? '0x' + pad64HexString : pad64HexString\r\n}\r\n\r\nexport function SHA256Hash(toHash: string): string {\r\n    var hash = sha256(toHash).toString()\r\n    return hash\r\n}\r\n",";(function (root, factory) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory();\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\troot.CryptoJS = factory();\n\t}\n}(this, function () {\n\n\t/*globals window, global, require*/\n\n\t/**\n\t * CryptoJS core components.\n\t */\n\tvar CryptoJS = CryptoJS || (function (Math, undefined) {\n\n\t    var crypto;\n\n\t    // Native crypto from window (Browser)\n\t    if (typeof window !== 'undefined' && window.crypto) {\n\t        crypto = window.crypto;\n\t    }\n\n\t    // Native (experimental IE 11) crypto from window (Browser)\n\t    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {\n\t        crypto = window.msCrypto;\n\t    }\n\n\t    // Native crypto from global (NodeJS)\n\t    if (!crypto && typeof global !== 'undefined' && global.crypto) {\n\t        crypto = global.crypto;\n\t    }\n\n\t    // Native crypto import via require (NodeJS)\n\t    if (!crypto && typeof require === 'function') {\n\t        try {\n\t            crypto = require('crypto');\n\t        } catch (err) {}\n\t    }\n\n\t    /*\n\t     * Cryptographically secure pseudorandom number generator\n\t     *\n\t     * As Math.random() is cryptographically not safe to use\n\t     */\n\t    var cryptoSecureRandomInt = function () {\n\t        if (crypto) {\n\t            // Use getRandomValues method (Browser)\n\t            if (typeof crypto.getRandomValues === 'function') {\n\t                try {\n\t                    return crypto.getRandomValues(new Uint32Array(1))[0];\n\t                } catch (err) {}\n\t            }\n\n\t            // Use randomBytes method (NodeJS)\n\t            if (typeof crypto.randomBytes === 'function') {\n\t                try {\n\t                    return crypto.randomBytes(4).readInt32LE();\n\t                } catch (err) {}\n\t            }\n\t        }\n\n\t        throw new Error('Native crypto module could not be used to get secure random number.');\n\t    };\n\n\t    /*\n\t     * Local polyfill of Object.create\n\n\t     */\n\t    var create = Object.create || (function () {\n\t        function F() {}\n\n\t        return function (obj) {\n\t            var subtype;\n\n\t            F.prototype = obj;\n\n\t            subtype = new F();\n\n\t            F.prototype = null;\n\n\t            return subtype;\n\t        };\n\t    }())\n\n\t    /**\n\t     * CryptoJS namespace.\n\t     */\n\t    var C = {};\n\n\t    /**\n\t     * Library namespace.\n\t     */\n\t    var C_lib = C.lib = {};\n\n\t    /**\n\t     * Base object for prototypal inheritance.\n\t     */\n\t    var Base = C_lib.Base = (function () {\n\n\n\t        return {\n\t            /**\n\t             * Creates a new object that inherits from this object.\n\t             *\n\t             * @param {Object} overrides Properties to copy into the new object.\n\t             *\n\t             * @return {Object} The new object.\n\t             *\n\t             * @static\n\t             *\n\t             * @example\n\t             *\n\t             *     var MyType = CryptoJS.lib.Base.extend({\n\t             *         field: 'value',\n\t             *\n\t             *         method: function () {\n\t             *         }\n\t             *     });\n\t             */\n\t            extend: function (overrides) {\n\t                // Spawn\n\t                var subtype = create(this);\n\n\t                // Augment\n\t                if (overrides) {\n\t                    subtype.mixIn(overrides);\n\t                }\n\n\t                // Create default initializer\n\t                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {\n\t                    subtype.init = function () {\n\t                        subtype.$super.init.apply(this, arguments);\n\t                    };\n\t                }\n\n\t                // Initializer's prototype is the subtype object\n\t                subtype.init.prototype = subtype;\n\n\t                // Reference supertype\n\t                subtype.$super = this;\n\n\t                return subtype;\n\t            },\n\n\t            /**\n\t             * Extends this object and runs the init method.\n\t             * Arguments to create() will be passed to init().\n\t             *\n\t             * @return {Object} The new object.\n\t             *\n\t             * @static\n\t             *\n\t             * @example\n\t             *\n\t             *     var instance = MyType.create();\n\t             */\n\t            create: function () {\n\t                var instance = this.extend();\n\t                instance.init.apply(instance, arguments);\n\n\t                return instance;\n\t            },\n\n\t            /**\n\t             * Initializes a newly created object.\n\t             * Override this method to add some logic when your objects are created.\n\t             *\n\t             * @example\n\t             *\n\t             *     var MyType = CryptoJS.lib.Base.extend({\n\t             *         init: function () {\n\t             *             // ...\n\t             *         }\n\t             *     });\n\t             */\n\t            init: function () {\n\t            },\n\n\t            /**\n\t             * Copies properties into this object.\n\t             *\n\t             * @param {Object} properties The properties to mix in.\n\t             *\n\t             * @example\n\t             *\n\t             *     MyType.mixIn({\n\t             *         field: 'value'\n\t             *     });\n\t             */\n\t            mixIn: function (properties) {\n\t                for (var propertyName in properties) {\n\t                    if (properties.hasOwnProperty(propertyName)) {\n\t                        this[propertyName] = properties[propertyName];\n\t                    }\n\t                }\n\n\t                // IE won't copy toString using the loop above\n\t                if (properties.hasOwnProperty('toString')) {\n\t                    this.toString = properties.toString;\n\t                }\n\t            },\n\n\t            /**\n\t             * Creates a copy of this object.\n\t             *\n\t             * @return {Object} The clone.\n\t             *\n\t             * @example\n\t             *\n\t             *     var clone = instance.clone();\n\t             */\n\t            clone: function () {\n\t                return this.init.prototype.extend(this);\n\t            }\n\t        };\n\t    }());\n\n\t    /**\n\t     * An array of 32-bit words.\n\t     *\n\t     * @property {Array} words The array of 32-bit words.\n\t     * @property {number} sigBytes The number of significant bytes in this word array.\n\t     */\n\t    var WordArray = C_lib.WordArray = Base.extend({\n\t        /**\n\t         * Initializes a newly created word array.\n\t         *\n\t         * @param {Array} words (Optional) An array of 32-bit words.\n\t         * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.lib.WordArray.create();\n\t         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);\n\t         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);\n\t         */\n\t        init: function (words, sigBytes) {\n\t            words = this.words = words || [];\n\n\t            if (sigBytes != undefined) {\n\t                this.sigBytes = sigBytes;\n\t            } else {\n\t                this.sigBytes = words.length * 4;\n\t            }\n\t        },\n\n\t        /**\n\t         * Converts this word array to a string.\n\t         *\n\t         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n\t         *\n\t         * @return {string} The stringified word array.\n\t         *\n\t         * @example\n\t         *\n\t         *     var string = wordArray + '';\n\t         *     var string = wordArray.toString();\n\t         *     var string = wordArray.toString(CryptoJS.enc.Utf8);\n\t         */\n\t        toString: function (encoder) {\n\t            return (encoder || Hex).stringify(this);\n\t        },\n\n\t        /**\n\t         * Concatenates a word array to this word array.\n\t         *\n\t         * @param {WordArray} wordArray The word array to append.\n\t         *\n\t         * @return {WordArray} This word array.\n\t         *\n\t         * @example\n\t         *\n\t         *     wordArray1.concat(wordArray2);\n\t         */\n\t        concat: function (wordArray) {\n\t            // Shortcuts\n\t            var thisWords = this.words;\n\t            var thatWords = wordArray.words;\n\t            var thisSigBytes = this.sigBytes;\n\t            var thatSigBytes = wordArray.sigBytes;\n\n\t            // Clamp excess bits\n\t            this.clamp();\n\n\t            // Concat\n\t            if (thisSigBytes % 4) {\n\t                // Copy one byte at a time\n\t                for (var i = 0; i < thatSigBytes; i++) {\n\t                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);\n\t                }\n\t            } else {\n\t                // Copy one word at a time\n\t                for (var i = 0; i < thatSigBytes; i += 4) {\n\t                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];\n\t                }\n\t            }\n\t            this.sigBytes += thatSigBytes;\n\n\t            // Chainable\n\t            return this;\n\t        },\n\n\t        /**\n\t         * Removes insignificant bits.\n\t         *\n\t         * @example\n\t         *\n\t         *     wordArray.clamp();\n\t         */\n\t        clamp: function () {\n\t            // Shortcuts\n\t            var words = this.words;\n\t            var sigBytes = this.sigBytes;\n\n\t            // Clamp\n\t            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);\n\t            words.length = Math.ceil(sigBytes / 4);\n\t        },\n\n\t        /**\n\t         * Creates a copy of this word array.\n\t         *\n\t         * @return {WordArray} The clone.\n\t         *\n\t         * @example\n\t         *\n\t         *     var clone = wordArray.clone();\n\t         */\n\t        clone: function () {\n\t            var clone = Base.clone.call(this);\n\t            clone.words = this.words.slice(0);\n\n\t            return clone;\n\t        },\n\n\t        /**\n\t         * Creates a word array filled with random bytes.\n\t         *\n\t         * @param {number} nBytes The number of random bytes to generate.\n\t         *\n\t         * @return {WordArray} The random word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.lib.WordArray.random(16);\n\t         */\n\t        random: function (nBytes) {\n\t            var words = [];\n\n\t            for (var i = 0; i < nBytes; i += 4) {\n\t                words.push(cryptoSecureRandomInt());\n\t            }\n\n\t            return new WordArray.init(words, nBytes);\n\t        }\n\t    });\n\n\t    /**\n\t     * Encoder namespace.\n\t     */\n\t    var C_enc = C.enc = {};\n\n\t    /**\n\t     * Hex encoding strategy.\n\t     */\n\t    var Hex = C_enc.Hex = {\n\t        /**\n\t         * Converts a word array to a hex string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The hex string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var hexChars = [];\n\t            for (var i = 0; i < sigBytes; i++) {\n\t                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                hexChars.push((bite >>> 4).toString(16));\n\t                hexChars.push((bite & 0x0f).toString(16));\n\t            }\n\n\t            return hexChars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a hex string to a word array.\n\t         *\n\t         * @param {string} hexStr The hex string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);\n\t         */\n\t        parse: function (hexStr) {\n\t            // Shortcut\n\t            var hexStrLength = hexStr.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < hexStrLength; i += 2) {\n\t                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\n\t            }\n\n\t            return new WordArray.init(words, hexStrLength / 2);\n\t        }\n\t    };\n\n\t    /**\n\t     * Latin1 encoding strategy.\n\t     */\n\t    var Latin1 = C_enc.Latin1 = {\n\t        /**\n\t         * Converts a word array to a Latin1 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The Latin1 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var latin1Chars = [];\n\t            for (var i = 0; i < sigBytes; i++) {\n\t                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                latin1Chars.push(String.fromCharCode(bite));\n\t            }\n\n\t            return latin1Chars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a Latin1 string to a word array.\n\t         *\n\t         * @param {string} latin1Str The Latin1 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);\n\t         */\n\t        parse: function (latin1Str) {\n\t            // Shortcut\n\t            var latin1StrLength = latin1Str.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < latin1StrLength; i++) {\n\t                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\n\t            }\n\n\t            return new WordArray.init(words, latin1StrLength);\n\t        }\n\t    };\n\n\t    /**\n\t     * UTF-8 encoding strategy.\n\t     */\n\t    var Utf8 = C_enc.Utf8 = {\n\t        /**\n\t         * Converts a word array to a UTF-8 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The UTF-8 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            try {\n\t                return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n\t            } catch (e) {\n\t                throw new Error('Malformed UTF-8 data');\n\t            }\n\t        },\n\n\t        /**\n\t         * Converts a UTF-8 string to a word array.\n\t         *\n\t         * @param {string} utf8Str The UTF-8 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);\n\t         */\n\t        parse: function (utf8Str) {\n\t            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n\t        }\n\t    };\n\n\t    /**\n\t     * Abstract buffered block algorithm template.\n\t     *\n\t     * The property blockSize must be implemented in a concrete subtype.\n\t     *\n\t     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0\n\t     */\n\t    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({\n\t        /**\n\t         * Resets this block algorithm's data buffer to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     bufferedBlockAlgorithm.reset();\n\t         */\n\t        reset: function () {\n\t            // Initial values\n\t            this._data = new WordArray.init();\n\t            this._nDataBytes = 0;\n\t        },\n\n\t        /**\n\t         * Adds new data to this block algorithm's buffer.\n\t         *\n\t         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.\n\t         *\n\t         * @example\n\t         *\n\t         *     bufferedBlockAlgorithm._append('data');\n\t         *     bufferedBlockAlgorithm._append(wordArray);\n\t         */\n\t        _append: function (data) {\n\t            // Convert string to WordArray, else assume WordArray already\n\t            if (typeof data == 'string') {\n\t                data = Utf8.parse(data);\n\t            }\n\n\t            // Append\n\t            this._data.concat(data);\n\t            this._nDataBytes += data.sigBytes;\n\t        },\n\n\t        /**\n\t         * Processes available data blocks.\n\t         *\n\t         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n\t         *\n\t         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\n\t         *\n\t         * @return {WordArray} The processed data.\n\t         *\n\t         * @example\n\t         *\n\t         *     var processedData = bufferedBlockAlgorithm._process();\n\t         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');\n\t         */\n\t        _process: function (doFlush) {\n\t            var processedWords;\n\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\t            var dataSigBytes = data.sigBytes;\n\t            var blockSize = this.blockSize;\n\t            var blockSizeBytes = blockSize * 4;\n\n\t            // Count blocks ready\n\t            var nBlocksReady = dataSigBytes / blockSizeBytes;\n\t            if (doFlush) {\n\t                // Round up to include partial blocks\n\t                nBlocksReady = Math.ceil(nBlocksReady);\n\t            } else {\n\t                // Round down to include only full blocks,\n\t                // less the number of blocks that must remain in the buffer\n\t                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n\t            }\n\n\t            // Count words ready\n\t            var nWordsReady = nBlocksReady * blockSize;\n\n\t            // Count bytes ready\n\t            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n\n\t            // Process blocks\n\t            if (nWordsReady) {\n\t                for (var offset = 0; offset < nWordsReady; offset += blockSize) {\n\t                    // Perform concrete-algorithm logic\n\t                    this._doProcessBlock(dataWords, offset);\n\t                }\n\n\t                // Remove processed words\n\t                processedWords = dataWords.splice(0, nWordsReady);\n\t                data.sigBytes -= nBytesReady;\n\t            }\n\n\t            // Return processed words\n\t            return new WordArray.init(processedWords, nBytesReady);\n\t        },\n\n\t        /**\n\t         * Creates a copy of this object.\n\t         *\n\t         * @return {Object} The clone.\n\t         *\n\t         * @example\n\t         *\n\t         *     var clone = bufferedBlockAlgorithm.clone();\n\t         */\n\t        clone: function () {\n\t            var clone = Base.clone.call(this);\n\t            clone._data = this._data.clone();\n\n\t            return clone;\n\t        },\n\n\t        _minBufferSize: 0\n\t    });\n\n\t    /**\n\t     * Abstract hasher template.\n\t     *\n\t     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)\n\t     */\n\t    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({\n\t        /**\n\t         * Configuration options.\n\t         */\n\t        cfg: Base.extend(),\n\n\t        /**\n\t         * Initializes a newly created hasher.\n\t         *\n\t         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hasher = CryptoJS.algo.SHA256.create();\n\t         */\n\t        init: function (cfg) {\n\t            // Apply config defaults\n\t            this.cfg = this.cfg.extend(cfg);\n\n\t            // Set initial values\n\t            this.reset();\n\t        },\n\n\t        /**\n\t         * Resets this hasher to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     hasher.reset();\n\t         */\n\t        reset: function () {\n\t            // Reset data buffer\n\t            BufferedBlockAlgorithm.reset.call(this);\n\n\t            // Perform concrete-hasher logic\n\t            this._doReset();\n\t        },\n\n\t        /**\n\t         * Updates this hasher with a message.\n\t         *\n\t         * @param {WordArray|string} messageUpdate The message to append.\n\t         *\n\t         * @return {Hasher} This hasher.\n\t         *\n\t         * @example\n\t         *\n\t         *     hasher.update('message');\n\t         *     hasher.update(wordArray);\n\t         */\n\t        update: function (messageUpdate) {\n\t            // Append\n\t            this._append(messageUpdate);\n\n\t            // Update the hash\n\t            this._process();\n\n\t            // Chainable\n\t            return this;\n\t        },\n\n\t        /**\n\t         * Finalizes the hash computation.\n\t         * Note that the finalize operation is effectively a destructive, read-once operation.\n\t         *\n\t         * @param {WordArray|string} messageUpdate (Optional) A final message update.\n\t         *\n\t         * @return {WordArray} The hash.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hash = hasher.finalize();\n\t         *     var hash = hasher.finalize('message');\n\t         *     var hash = hasher.finalize(wordArray);\n\t         */\n\t        finalize: function (messageUpdate) {\n\t            // Final message update\n\t            if (messageUpdate) {\n\t                this._append(messageUpdate);\n\t            }\n\n\t            // Perform concrete-hasher logic\n\t            var hash = this._doFinalize();\n\n\t            return hash;\n\t        },\n\n\t        blockSize: 512/32,\n\n\t        /**\n\t         * Creates a shortcut function to a hasher's object interface.\n\t         *\n\t         * @param {Hasher} hasher The hasher to create a helper for.\n\t         *\n\t         * @return {Function} The shortcut function.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);\n\t         */\n\t        _createHelper: function (hasher) {\n\t            return function (message, cfg) {\n\t                return new hasher.init(cfg).finalize(message);\n\t            };\n\t        },\n\n\t        /**\n\t         * Creates a shortcut function to the HMAC's object interface.\n\t         *\n\t         * @param {Hasher} hasher The hasher to use in this HMAC helper.\n\t         *\n\t         * @return {Function} The shortcut function.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);\n\t         */\n\t        _createHmacHelper: function (hasher) {\n\t            return function (message, key) {\n\t                return new C_algo.HMAC.init(hasher, key).finalize(message);\n\t            };\n\t        }\n\t    });\n\n\t    /**\n\t     * Algorithm namespace.\n\t     */\n\t    var C_algo = C.algo = {};\n\n\t    return C;\n\t}(Math));\n\n\n\treturn CryptoJS;\n\n}));",";(function (root, factory) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t(function (Math) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_algo = C.algo;\n\n\t    // Initialization and round constants tables\n\t    var H = [];\n\t    var K = [];\n\n\t    // Compute constants\n\t    (function () {\n\t        function isPrime(n) {\n\t            var sqrtN = Math.sqrt(n);\n\t            for (var factor = 2; factor <= sqrtN; factor++) {\n\t                if (!(n % factor)) {\n\t                    return false;\n\t                }\n\t            }\n\n\t            return true;\n\t        }\n\n\t        function getFractionalBits(n) {\n\t            return ((n - (n | 0)) * 0x100000000) | 0;\n\t        }\n\n\t        var n = 2;\n\t        var nPrime = 0;\n\t        while (nPrime < 64) {\n\t            if (isPrime(n)) {\n\t                if (nPrime < 8) {\n\t                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));\n\t                }\n\t                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));\n\n\t                nPrime++;\n\t            }\n\n\t            n++;\n\t        }\n\t    }());\n\n\t    // Reusable object\n\t    var W = [];\n\n\t    /**\n\t     * SHA-256 hash algorithm.\n\t     */\n\t    var SHA256 = C_algo.SHA256 = Hasher.extend({\n\t        _doReset: function () {\n\t            this._hash = new WordArray.init(H.slice(0));\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcut\n\t            var H = this._hash.words;\n\n\t            // Working variables\n\t            var a = H[0];\n\t            var b = H[1];\n\t            var c = H[2];\n\t            var d = H[3];\n\t            var e = H[4];\n\t            var f = H[5];\n\t            var g = H[6];\n\t            var h = H[7];\n\n\t            // Computation\n\t            for (var i = 0; i < 64; i++) {\n\t                if (i < 16) {\n\t                    W[i] = M[offset + i] | 0;\n\t                } else {\n\t                    var gamma0x = W[i - 15];\n\t                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^\n\t                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^\n\t                                   (gamma0x >>> 3);\n\n\t                    var gamma1x = W[i - 2];\n\t                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^\n\t                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^\n\t                                   (gamma1x >>> 10);\n\n\t                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n\t                }\n\n\t                var ch  = (e & f) ^ (~e & g);\n\t                var maj = (a & b) ^ (a & c) ^ (b & c);\n\n\t                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));\n\t                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));\n\n\t                var t1 = h + sigma1 + ch + K[i] + W[i];\n\t                var t2 = sigma0 + maj;\n\n\t                h = g;\n\t                g = f;\n\t                f = e;\n\t                e = (d + t1) | 0;\n\t                d = c;\n\t                c = b;\n\t                b = a;\n\t                a = (t1 + t2) | 0;\n\t            }\n\n\t            // Intermediate hash value\n\t            H[0] = (H[0] + a) | 0;\n\t            H[1] = (H[1] + b) | 0;\n\t            H[2] = (H[2] + c) | 0;\n\t            H[3] = (H[3] + d) | 0;\n\t            H[4] = (H[4] + e) | 0;\n\t            H[5] = (H[5] + f) | 0;\n\t            H[6] = (H[6] + g) | 0;\n\t            H[7] = (H[7] + h) | 0;\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n\t            data.sigBytes = dataWords.length * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Return final computed hash\n\t            return this._hash;\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\t            clone._hash = this._hash.clone();\n\n\t            return clone;\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA256('message');\n\t     *     var hash = CryptoJS.SHA256(wordArray);\n\t     */\n\t    C.SHA256 = Hasher._createHelper(SHA256);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA256(message, key);\n\t     */\n\t    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);\n\t}(Math));\n\n\n\treturn CryptoJS.SHA256;\n\n}));","'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst CURVE = {\n    a: 0n,\n    b: 7n,\n    P: 2n ** 256n - 2n ** 32n - 977n,\n    n: 2n ** 256n - 432420386565659656852420866394968145599n,\n    h: 1n,\n    Gx: 55066263022277343669578718895168534326250603453777594175500187360389116729240n,\n    Gy: 32670510020758816978083085130507043184471273380659243275938904335757337482424n,\n    beta: 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501een,\n};\nexports.CURVE = CURVE;\nconst PRIME_SIZE = 256;\nconst P_DIV4_1 = (CURVE.P + 1n) / 4n;\nfunction weistrass(x) {\n    const { a, b } = CURVE;\n    return mod(x ** 3n + a * x + b);\n}\nconst USE_ENDOMORPHISM = CURVE.a === 0n;\nclass JacobianPoint {\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    static fromAffine(p) {\n        if (!(p instanceof Point)) {\n            throw new TypeError('JacobianPoint#fromAffine: expected Point');\n        }\n        return new JacobianPoint(p.x, p.y, 1n);\n    }\n    static toAffineBatch(points) {\n        const toInv = invertBatch(points.map((p) => p.z));\n        return points.map((p, i) => p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n        return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);\n    }\n    equals(other) {\n        const a = this;\n        const b = other;\n        const az2 = mod(a.z * a.z);\n        const az3 = mod(a.z * az2);\n        const bz2 = mod(b.z * b.z);\n        const bz3 = mod(b.z * bz2);\n        return mod(a.x * bz2) === mod(az2 * b.x) && mod(a.y * bz3) === mod(az3 * b.y);\n    }\n    negate() {\n        return new JacobianPoint(this.x, mod(-this.y), this.z);\n    }\n    double() {\n        const X1 = this.x;\n        const Y1 = this.y;\n        const Z1 = this.z;\n        const A = X1 ** 2n;\n        const B = Y1 ** 2n;\n        const C = B ** 2n;\n        const D = 2n * ((X1 + B) ** 2n - A - C);\n        const E = 3n * A;\n        const F = E ** 2n;\n        const X3 = mod(F - 2n * D);\n        const Y3 = mod(E * (D - X3) - 8n * C);\n        const Z3 = mod(2n * Y1 * Z1);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    add(other) {\n        if (!(other instanceof JacobianPoint)) {\n            throw new TypeError('JacobianPoint#add: expected JacobianPoint');\n        }\n        const X1 = this.x;\n        const Y1 = this.y;\n        const Z1 = this.z;\n        const X2 = other.x;\n        const Y2 = other.y;\n        const Z2 = other.z;\n        if (X2 === 0n || Y2 === 0n)\n            return this;\n        if (X1 === 0n || Y1 === 0n)\n            return other;\n        const Z1Z1 = Z1 ** 2n;\n        const Z2Z2 = Z2 ** 2n;\n        const U1 = X1 * Z2Z2;\n        const U2 = X2 * Z1Z1;\n        const S1 = Y1 * Z2 * Z2Z2;\n        const S2 = Y2 * Z1 * Z1Z1;\n        const H = mod(U2 - U1);\n        const r = mod(S2 - S1);\n        if (H === 0n) {\n            if (r === 0n) {\n                return this.double();\n            }\n            else {\n                return JacobianPoint.ZERO;\n            }\n        }\n        const HH = mod(H ** 2n);\n        const HHH = mod(H * HH);\n        const V = U1 * HH;\n        const X3 = mod(r ** 2n - HHH - 2n * V);\n        const Y3 = mod(r * (V - X3) - S1 * HHH);\n        const Z3 = mod(Z1 * Z2 * H);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    multiplyUnsafe(scalar) {\n        if (typeof scalar !== 'number' && typeof scalar !== 'bigint') {\n            throw new TypeError('Point#multiply: expected number or bigint');\n        }\n        let n = mod(BigInt(scalar), CURVE.n);\n        if (n <= 0) {\n            throw new Error('Point#multiply: invalid scalar, expected positive integer');\n        }\n        if (!USE_ENDOMORPHISM) {\n            let p = JacobianPoint.ZERO;\n            let d = this;\n            while (n > 0n) {\n                if (n & 1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= 1n;\n            }\n            return p;\n        }\n        let [k1neg, k1, k2neg, k2] = splitScalarEndo(n);\n        let k1p = JacobianPoint.ZERO;\n        let k2p = JacobianPoint.ZERO;\n        let d = this;\n        while (k1 > 0n || k2 > 0n) {\n            if (k1 & 1n)\n                k1p = k1p.add(d);\n            if (k2 & 1n)\n                k2p = k2p.add(d);\n            d = d.double();\n            k1 >>= 1n;\n            k2 >>= 1n;\n        }\n        if (k1neg)\n            k1p = k1p.negate();\n        if (k2neg)\n            k2p = k2p.negate();\n        k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);\n        return k1p.add(k2p);\n    }\n    precomputeWindow(W) {\n        const windows = USE_ENDOMORPHISM ? 128 / W + 2 : 256 / W + 1;\n        let points = [];\n        let p = this;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            for (let i = 1; i < 2 ** (W - 1); i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    wNAF(n, affinePoint) {\n        if (!affinePoint && this.equals(JacobianPoint.BASE))\n            affinePoint = Point.BASE;\n        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;\n        if (256 % W) {\n            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n        }\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n        if (!precomputes) {\n            precomputes = this.precomputeWindow(W);\n            if (affinePoint && W !== 1) {\n                precomputes = JacobianPoint.normalizeZ(precomputes);\n                pointPrecomputes.set(affinePoint, precomputes);\n            }\n        }\n        let p = JacobianPoint.ZERO;\n        let f = JacobianPoint.ZERO;\n        const windows = USE_ENDOMORPHISM ? 128 / W + 2 : 256 / W + 1;\n        const windowSize = 2 ** (W - 1);\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for (let window = 0; window < windows; window++) {\n            const offset = window * windowSize;\n            let wbits = Number(n & mask);\n            n >>= shiftBy;\n            if (wbits > windowSize) {\n                wbits -= maxNumber;\n                n += 1n;\n            }\n            if (wbits === 0) {\n                f = f.add(window % 2 ? precomputes[offset].negate() : precomputes[offset]);\n            }\n            else {\n                const cached = precomputes[offset + Math.abs(wbits) - 1];\n                p = p.add(wbits < 0 ? cached.negate() : cached);\n            }\n        }\n        return [p, f];\n    }\n    multiply(scalar, affinePoint) {\n        if (typeof scalar !== 'number' && typeof scalar !== 'bigint') {\n            throw new TypeError('Point#multiply: expected number or bigint');\n        }\n        let n = mod(BigInt(scalar), CURVE.n);\n        if (n <= 0) {\n            throw new Error('Point#multiply: invalid scalar, expected positive integer');\n        }\n        let point;\n        let fake;\n        if (USE_ENDOMORPHISM) {\n            const [k1neg, k1, k2neg, k2] = splitScalarEndo(n);\n            let k1p, k2p, f1p, f2p;\n            [k1p, f1p] = this.wNAF(k1, affinePoint);\n            [k2p, f2p] = this.wNAF(k2, affinePoint);\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);\n            [point, fake] = [k1p.add(k2p), f1p.add(f2p)];\n        }\n        else {\n            [point, fake] = this.wNAF(n, affinePoint);\n        }\n        return JacobianPoint.normalizeZ([point, fake])[0];\n    }\n    toAffine(invZ = invert(this.z)) {\n        const invZ2 = invZ ** 2n;\n        const x = mod(this.x * invZ2);\n        const y = mod(this.y * invZ2 * invZ);\n        return new Point(x, y);\n    }\n}\nJacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, 1n);\nJacobianPoint.ZERO = new JacobianPoint(0n, 1n, 0n);\nconst pointPrecomputes = new WeakMap();\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n    }\n    static fromX(bytes) {\n        const x = bytesToNumber(bytes);\n        const sqrY = weistrass(x);\n        let y = powMod(sqrY, P_DIV4_1, CURVE.P);\n        const isYOdd = (y & 1n) === 1n;\n        if (isYOdd)\n            y = mod(-y);\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromCompressedHex(bytes) {\n        if (bytes.length !== 33) {\n            throw new TypeError(`Point.fromHex: compressed expects 33 bytes, not ${bytes.length * 2}`);\n        }\n        const x = bytesToNumber(bytes.slice(1));\n        const sqrY = weistrass(x);\n        let y = powMod(sqrY, P_DIV4_1, CURVE.P);\n        const isFirstByteOdd = (bytes[0] & 1) === 1;\n        const isYOdd = (y & 1n) === 1n;\n        if (isFirstByteOdd !== isYOdd)\n            y = mod(-y);\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromUncompressedHex(bytes) {\n        if (bytes.length !== 65) {\n            throw new TypeError(`Point.fromHex: uncompressed expects 65 bytes, not ${bytes.length * 2}`);\n        }\n        const x = bytesToNumber(bytes.slice(1, 33));\n        const y = bytesToNumber(bytes.slice(33));\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromHex(hex) {\n        const bytes = hex instanceof Uint8Array ? hex : hexToBytes(hex);\n        if (bytes.length === 32)\n            return this.fromX(bytes);\n        const header = bytes[0];\n        if (header === 0x02 || header === 0x03)\n            return this.fromCompressedHex(bytes);\n        if (header === 0x04)\n            return this.fromUncompressedHex(bytes);\n        throw new TypeError('Point.fromHex: received invalid point');\n    }\n    static fromPrivateKey(privateKey) {\n        return Point.BASE.multiply(normalizePrivateKey(privateKey));\n    }\n    static fromSignature(msgHash, signature, recovery) {\n        const sign = normalizeSignature(signature);\n        const { r, s } = sign;\n        if (r === 0n || s === 0n)\n            return;\n        const rinv = invert(r, CURVE.n);\n        const h = typeof msgHash === 'string' ? hexToNumber(msgHash) : bytesToNumber(msgHash);\n        const P_ = Point.fromHex(`0${2 + (recovery & 1)}${pad64(r)}`);\n        const sP = JacobianPoint.fromAffine(P_).multiplyUnsafe(s);\n        const hG = JacobianPoint.BASE.multiply(h).negate();\n        const Q = sP.add(hG).multiplyUnsafe(rinv);\n        const point = Q.toAffine();\n        point.assertValidity();\n        return point;\n    }\n    toRawBytes(isCompressed = false) {\n        return hexToBytes(this.toHex(isCompressed));\n    }\n    toHex(isCompressed = false) {\n        const x = pad64(this.x);\n        if (isCompressed) {\n            return `${this.y & 1n ? '03' : '02'}${x}`;\n        }\n        else {\n            return `04${x}${pad64(this.y)}`;\n        }\n    }\n    toHexX() {\n        return this.toHex(true).slice(2);\n    }\n    toRawX() {\n        return this.toRawBytes(true).slice(1);\n    }\n    assertValidity() {\n        const { x, y } = this;\n        if (x === 0n || y === 0n || x >= CURVE.P || y >= CURVE.P) {\n            throw new TypeError('Point is not on elliptic curve');\n        }\n        const left = mod(y * y);\n        const right = weistrass(x);\n        const valid = (left - right) % CURVE.P === 0n;\n        if (!valid)\n            throw new TypeError('Point is not on elliptic curve');\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n        return new Point(this.x, mod(-this.y));\n    }\n    double() {\n        return JacobianPoint.fromAffine(this).double().toAffine();\n    }\n    add(other) {\n        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiply(scalar) {\n        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n}\nexports.Point = Point;\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(0n, 0n);\nfunction sliceDer(s) {\n    return parseInt(s[0], 16) >= 8 ? '00' + s : s;\n}\nclass Signature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n    }\n    static fromHex(hex) {\n        const str = hex instanceof Uint8Array ? bytesToHex(hex) : hex;\n        if (typeof str !== 'string')\n            throw new TypeError({}.toString.call(hex));\n        const check1 = str.slice(0, 2);\n        const length = parseByte(str.slice(2, 4));\n        const check2 = str.slice(4, 6);\n        if (check1 !== '30' || length !== str.length - 4 || check2 !== '02') {\n            throw new Error('Signature.fromHex: Invalid signature');\n        }\n        const rLen = parseByte(str.slice(6, 8));\n        const rEnd = 8 + rLen;\n        const r = hexToNumber(str.slice(8, rEnd));\n        const check3 = str.slice(rEnd, rEnd + 2);\n        if (check3 !== '02') {\n            throw new Error('SignResult.fromHex: Invalid signature');\n        }\n        const sLen = parseByte(str.slice(rEnd + 2, rEnd + 4));\n        const sStart = rEnd + 4;\n        const s = hexToNumber(str.slice(sStart, sStart + sLen));\n        return new Signature(r, s);\n    }\n    toRawBytes(isCompressed = false) {\n        return hexToBytes(this.toHex(isCompressed));\n    }\n    toHex(isCompressed = false) {\n        const sHex = sliceDer(numberToHex(this.s));\n        if (isCompressed)\n            return sHex;\n        const rHex = sliceDer(numberToHex(this.r));\n        const rLen = numberToHex(rHex.length / 2);\n        const sLen = numberToHex(sHex.length / 2);\n        const length = numberToHex(rHex.length / 2 + sHex.length / 2 + 4);\n        return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;\n    }\n}\nexports.Signature = Signature;\nexports.SignResult = Signature;\nfunction concatBytes(...arrays) {\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nfunction bytesToHex(uint8a) {\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += uint8a[i].toString(16).padStart(2, '0');\n    }\n    return hex;\n}\nfunction pad64(num) {\n    return num.toString(16).padStart(64, '0');\n}\nfunction pad32b(num) {\n    return hexToBytes(pad64(num));\n}\nfunction numberToHex(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToNumber: expected string, got ' + typeof hex);\n    }\n    return BigInt(`0x${hex}`);\n}\nfunction hexToBytes(hex) {\n    hex = hex.length & 1 ? `0${hex}` : hex;\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        let j = i * 2;\n        array[i] = Number.parseInt(hex.slice(j, j + 2), 16);\n    }\n    return array;\n}\nfunction bytesToNumber(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction parseByte(str) {\n    return Number.parseInt(str, 16) * 2;\n}\nfunction mod(a, b = CURVE.P) {\n    const result = a % b;\n    return result >= 0 ? result : b + result;\n}\nfunction powMod(x, power, order) {\n    let res = 1n;\n    while (power > 0) {\n        if (power & 1n) {\n            res = mod(res * x, order);\n        }\n        power >>= 1n;\n        x = mod(x * x, order);\n    }\n    return res;\n}\nfunction egcd(a, b) {\n    let [x, y, u, v] = [0n, 1n, 1n, 0n];\n    while (a !== 0n) {\n        let q = b / a;\n        let r = b % a;\n        let m = x - u * q;\n        let n = y - v * q;\n        [b, a] = [a, r];\n        [x, y] = [u, v];\n        [u, v] = [m, n];\n    }\n    const gcd = b;\n    return [gcd, x, y];\n}\nfunction invert(number, modulo = CURVE.P) {\n    if (number === 0n || modulo <= 0n) {\n        throw new Error('invert: expected positive integers');\n    }\n    const [gcd, x] = egcd(mod(number, modulo), modulo);\n    if (gcd !== 1n) {\n        throw new Error('invert: does not exist');\n    }\n    return mod(x, modulo);\n}\nfunction invertBatch(nums, n = CURVE.P) {\n    const len = nums.length;\n    const scratch = new Array(len);\n    let acc = 1n;\n    for (let i = 0; i < len; i++) {\n        if (nums[i] === 0n)\n            continue;\n        scratch[i] = acc;\n        acc = mod(acc * nums[i], n);\n    }\n    acc = invert(acc, n);\n    for (let i = len - 1; i >= 0; i--) {\n        if (nums[i] === 0n)\n            continue;\n        let tmp = mod(acc * nums[i], n);\n        nums[i] = mod(acc * scratch[i], n);\n        acc = tmp;\n    }\n    return nums;\n}\nfunction splitScalarEndo(k) {\n    const { n } = CURVE;\n    const a1 = 0x3086d221a7d46bcde86c90e49284eb15n;\n    const b1 = -0xe4437ed6010e88286f547fa90abfe4c3n;\n    const a2 = 0x114ca50f7a8e2f3f657c1108d9d44cfd8n;\n    const b2 = a1;\n    const c1 = (b2 * k) / n;\n    const c2 = (-b1 * k) / n;\n    const k1 = k - c1 * a1 - c2 * a2;\n    const k2 = -c1 * b1 - c2 * b2;\n    const k1neg = k1 < 0;\n    const k2neg = k2 < 0;\n    return [k1neg, k1neg ? -k1 : k1, k2neg, k2neg ? -k2 : k2];\n}\nfunction truncateHash(hash) {\n    hash = typeof hash === 'string' ? hash : bytesToHex(hash);\n    let msg = hexToNumber(hash || '0');\n    const delta = (hash.length / 2) * 8 - PRIME_SIZE;\n    if (delta > 0) {\n        msg = msg >> BigInt(delta);\n    }\n    if (msg >= CURVE.n) {\n        msg -= CURVE.n;\n    }\n    return msg;\n}\nasync function getQRSrfc6979(msgHash, privateKey) {\n    const num = typeof msgHash === 'string' ? hexToNumber(msgHash) : bytesToNumber(msgHash);\n    const h1 = pad32b(num);\n    const x = pad32b(privateKey);\n    const h1n = bytesToNumber(h1);\n    let v = new Uint8Array(32).fill(1);\n    let k = new Uint8Array(32).fill(0);\n    const b0 = Uint8Array.from([0x00]);\n    const b1 = Uint8Array.from([0x01]);\n    k = await exports.utils.hmacSha256(k, v, b0, x, h1);\n    v = await exports.utils.hmacSha256(k, v);\n    k = await exports.utils.hmacSha256(k, v, b1, x, h1);\n    v = await exports.utils.hmacSha256(k, v);\n    for (let i = 0; i < 1000; i++) {\n        v = await exports.utils.hmacSha256(k, v);\n        const T = bytesToNumber(v);\n        let qrs;\n        if (isValidPrivateKey(T) && (qrs = calcQRSFromK(T, h1n, privateKey))) {\n            return qrs;\n        }\n        k = await exports.utils.hmacSha256(k, v, b0);\n        v = await exports.utils.hmacSha256(k, v);\n    }\n    throw new TypeError('secp256k1: Tried 1,000 k values for sign(), all were invalid');\n}\nfunction isValidPrivateKey(privateKey) {\n    return 0 < privateKey && privateKey < CURVE.n;\n}\nfunction calcQRSFromK(k, msg, priv) {\n    const max = CURVE.n;\n    const q = Point.BASE.multiply(k);\n    const r = mod(q.x, max);\n    const s = mod(invert(k, max) * (msg + r * priv), max);\n    if (r === 0n || s === 0n)\n        return;\n    return [q, r, s];\n}\nfunction normalizePrivateKey(privateKey) {\n    if (!privateKey)\n        throw new Error(`Expected receive valid private key, not \"${privateKey}\"`);\n    let key;\n    if (privateKey instanceof Uint8Array) {\n        key = bytesToNumber(privateKey);\n    }\n    else if (typeof privateKey === 'string') {\n        key = hexToNumber(privateKey);\n    }\n    else {\n        key = BigInt(privateKey);\n    }\n    return key;\n}\nfunction normalizePublicKey(publicKey) {\n    return publicKey instanceof Point ? publicKey : Point.fromHex(publicKey);\n}\nfunction normalizeSignature(signature) {\n    return signature instanceof Signature ? signature : Signature.fromHex(signature);\n}\nfunction getPublicKey(privateKey, isCompressed = false) {\n    const point = Point.fromPrivateKey(privateKey);\n    if (typeof privateKey === 'string') {\n        return point.toHex(isCompressed);\n    }\n    return point.toRawBytes(isCompressed);\n}\nexports.getPublicKey = getPublicKey;\nfunction recoverPublicKey(msgHash, signature, recovery) {\n    const point = Point.fromSignature(msgHash, signature, recovery);\n    if (!point)\n        return;\n    return typeof msgHash === 'string' ? point.toHex() : point.toRawBytes();\n}\nexports.recoverPublicKey = recoverPublicKey;\nfunction isPub(item) {\n    const arr = item instanceof Uint8Array;\n    const str = typeof item === 'string';\n    const len = (arr || str) && item.length;\n    if (arr)\n        return len === 33 || len === 65;\n    if (str)\n        return len === 66 || len === 130;\n    if (item instanceof Point)\n        return true;\n    return false;\n}\nfunction getSharedSecret(privateA, publicB, isCompressed = false) {\n    if (isPub(privateA) && !isPub(publicB)) {\n        [privateA, publicB] = [publicB, privateA];\n    }\n    else if (!isPub(publicB)) {\n        throw new Error('Received invalid keys');\n    }\n    const b = publicB instanceof Point ? publicB : Point.fromHex(publicB);\n    b.assertValidity();\n    const shared = b.multiply(normalizePrivateKey(privateA));\n    return typeof privateA === 'string'\n        ? shared.toHex(isCompressed)\n        : shared.toRawBytes(isCompressed);\n}\nexports.getSharedSecret = getSharedSecret;\nasync function sign(msgHash, privateKey, { recovered, canonical } = {}) {\n    if (msgHash == null)\n        throw new Error(`Expected valid msgHash, not \"${msgHash}\"`);\n    const priv = normalizePrivateKey(privateKey);\n    const [q, r, s] = await getQRSrfc6979(msgHash, priv);\n    let recovery = (q.x === r ? 0 : 2) | Number(q.y & 1n);\n    let adjustedS = s;\n    const HIGH_NUMBER = CURVE.n >> 1n;\n    if (s > HIGH_NUMBER && canonical) {\n        adjustedS = CURVE.n - s;\n        recovery ^= 1;\n    }\n    const sig = new Signature(r, adjustedS);\n    const hashed = typeof msgHash === 'string' ? sig.toHex() : sig.toRawBytes();\n    return recovered ? [hashed, recovery] : hashed;\n}\nexports.sign = sign;\nfunction verify(signature, msgHash, publicKey) {\n    const h = truncateHash(msgHash);\n    const { r, s } = normalizeSignature(signature);\n    const pubKey = JacobianPoint.fromAffine(normalizePublicKey(publicKey));\n    const s1 = invert(s, CURVE.n);\n    const Ghs1 = JacobianPoint.BASE.multiply(mod(h * s1, CURVE.n));\n    const Prs1 = pubKey.multiplyUnsafe(mod(r * s1, CURVE.n));\n    const res = Ghs1.add(Prs1).toAffine();\n    return res.x === r;\n}\nexports.verify = verify;\nasync function taggedHash(tag, ...messages) {\n    const tagB = new Uint8Array(tag.split('').map((c) => c.charCodeAt(0)));\n    const tagH = await exports.utils.sha256(tagB);\n    const h = await exports.utils.sha256(concatBytes(tagH, tagH, ...messages));\n    return bytesToNumber(h);\n}\nasync function createChallenge(x, P, message) {\n    const rx = pad32b(x);\n    const t = await taggedHash('BIP0340/challenge', rx, P.toRawX(), message);\n    return mod(t, CURVE.n);\n}\nfunction hasEvenY(point) {\n    return mod(point.y, 2n) === 0n;\n}\nclass SchnorrSignature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        if (r === 0n || s === 0n || r >= CURVE.P || s >= CURVE.n)\n            throw new Error('Invalid signature');\n    }\n    static fromHex(hex) {\n        const bytes = hex instanceof Uint8Array ? hex : hexToBytes(hex);\n        if (bytes.length !== 64) {\n            throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);\n        }\n        const r = bytesToNumber(bytes.slice(0, 32));\n        const s = bytesToNumber(bytes.slice(32));\n        return new SchnorrSignature(r, s);\n    }\n    toHex() {\n        return pad64(this.r) + pad64(this.s);\n    }\n    toRawBytes() {\n        return hexToBytes(this.toHex());\n    }\n}\nfunction schnorrGetPublicKey(privateKey) {\n    const P = Point.fromPrivateKey(privateKey);\n    return typeof privateKey === 'string' ? P.toHexX() : P.toRawX();\n}\nasync function schnorrSign(msgHash, privateKey, auxRand = exports.utils.randomPrivateKey()) {\n    if (msgHash == null)\n        throw new TypeError(`Expected valid message, not \"${msgHash}\"`);\n    if (!privateKey)\n        privateKey = 0n;\n    const { n } = CURVE;\n    const m = typeof msgHash === 'string' ? hexToBytes(msgHash) : msgHash;\n    const d0 = normalizePrivateKey(privateKey);\n    if (!(0 < d0 && d0 < n))\n        throw new Error('Invalid private key');\n    const rand = typeof auxRand === 'string' ? hexToBytes(auxRand) : auxRand;\n    if (rand.length !== 32)\n        throw new TypeError('Expected 32 bytes of aux randomness');\n    const P = Point.fromPrivateKey(d0);\n    const d = hasEvenY(P) ? d0 : n - d0;\n    const t0h = await taggedHash('BIP0340/aux', rand);\n    const t = d ^ t0h;\n    const k0h = await taggedHash('BIP0340/nonce', pad32b(t), P.toRawX(), m);\n    const k0 = mod(k0h, n);\n    if (k0 === 0n)\n        throw new Error('Creation of signature failed. k is zero');\n    const R = Point.fromPrivateKey(k0);\n    const k = hasEvenY(R) ? k0 : n - k0;\n    const e = await createChallenge(R.x, P, m);\n    const sig = new SchnorrSignature(R.x, mod(k + e * d, n));\n    const isValid = await schnorrVerify(sig.toRawBytes(), m, P.toRawX());\n    if (!isValid)\n        throw new Error('Invalid signature produced');\n    return typeof msgHash === 'string' ? sig.toHex() : sig.toRawBytes();\n}\nasync function schnorrVerify(signature, msgHash, publicKey) {\n    const sig = signature instanceof SchnorrSignature ? signature : SchnorrSignature.fromHex(signature);\n    const m = typeof msgHash === 'string' ? hexToBytes(msgHash) : msgHash;\n    const P = normalizePublicKey(publicKey);\n    const e = await createChallenge(sig.r, P, m);\n    const sG = Point.fromPrivateKey(sig.s);\n    const eP = P.multiply(e);\n    const R = sG.subtract(eP);\n    if (R.equals(Point.BASE) || !hasEvenY(R) || R.x !== sig.r)\n        return false;\n    return true;\n}\nexports.schnorr = {\n    Signature: SchnorrSignature,\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n};\nPoint.BASE._setWindowSize(8);\nexports.utils = {\n    isValidPrivateKey(privateKey) {\n        return isValidPrivateKey(normalizePrivateKey(privateKey));\n    },\n    randomPrivateKey: (bytesLength = 32) => {\n        if (typeof window == 'object' && 'crypto' in window) {\n            return window.crypto.getRandomValues(new Uint8Array(bytesLength));\n        }\n        else if (typeof process === 'object' && 'node' in process.versions) {\n            const { randomBytes } = require('crypto');\n            return new Uint8Array(randomBytes(bytesLength).buffer);\n        }\n        else {\n            throw new Error(\"The environment doesn't have randomBytes function\");\n        }\n    },\n    sha256: async (message) => {\n        if (typeof window == 'object' && 'crypto' in window) {\n            const buffer = await window.crypto.subtle.digest('SHA-256', message.buffer);\n            return new Uint8Array(buffer);\n        }\n        else if (typeof process === 'object' && 'node' in process.versions) {\n            const { createHash } = require('crypto');\n            return Uint8Array.from(createHash('sha256').update(message).digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have sha256 function\");\n        }\n    },\n    hmacSha256: async (key, ...messages) => {\n        if (typeof window == 'object' && 'crypto' in window) {\n            const ckey = await window.crypto.subtle.importKey('raw', key, { name: 'HMAC', hash: { name: 'SHA-256' } }, false, ['sign']);\n            const message = concatBytes(...messages);\n            const buffer = await window.crypto.subtle.sign('HMAC', ckey, message);\n            return new Uint8Array(buffer);\n        }\n        else if (typeof process === 'object' && 'node' in process.versions) {\n            const { createHmac, randomBytes } = require('crypto');\n            const hash = createHmac('sha256', key);\n            for (let message of messages) {\n                hash.update(message);\n            }\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have hmac-sha256 function\");\n        }\n    },\n    precompute(windowSize = 8, point = Point.BASE) {\n        const cached = point === Point.BASE ? point : new Point(point.x, point.y);\n        cached._setWindowSize(windowSize);\n        cached.multiply(3n);\n        return cached;\n    },\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(905);\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();"],"sourceRoot":""}