{"version":3,"sources":["webpack://jpake/webpack/universalModuleDefinition","webpack://jpake/./src/jpake.ts","webpack://jpake/./src/utils.ts","webpack://jpake/./node_modules/crypto-js/core.js","webpack://jpake/./node_modules/crypto-js/sha256.js","webpack://jpake/./node_modules/noble-secp256k1/index.js","webpack://jpake/webpack/bootstrap","webpack://jpake/webpack/startup","webpack://jpake/webpack/runtime/global"],"names":["root","factory","exports","module","define","amd","this","ZEROPOINT","secp","Point","CURVE","Gx","Gy","secret","hashFn","SHA256Hash","s","mod","BigInt","n","x1","randBetween","x2","G","x1G","multiply","x2G","x","Generator","y","v","t","equals","chal","asBase64String","c","r","tx","ty","add","msgObj","fromBase64String","pubVar","x1Gx","x1Gy","x2Gx","x2Gy","x1ZKP","computeZKP","x2ZKP","JSON","stringify","jsonStringFromB","otherPubVars","parse","otherx1G","otherx2G","x1Proof","checkZKPSimpler","x2Proof","x2s","A","Ax","Ay","xsZKP","otherA","B","ZKPGenerator","Ka","subtract","getRandomBits","bitLength","randBytes","byteLength","uint8Buf","Uint8Array","window","crypto","getRandomValues","process","versions","randomBytes","buffer","Error","getRandomBytes","Math","ceil","bitLengthMod8","fromBuffer","buf","ret","i","values","bi","min","max","RangeError","interval","bitLen","a","bits","rnd","add0x","pad64HexString","toString","padStart","toHash","BigIntBase64","fromInt","str","toInt","digits","split","digitsMap","length","int32","result","Number","digitsStr","CryptoJS","undefined","msCrypto","g","err","cryptoSecureRandomInt","Uint32Array","readInt32LE","create","Object","F","obj","subtype","prototype","C","C_lib","lib","Base","extend","overrides","mixIn","hasOwnProperty","init","$super","apply","arguments","instance","properties","propertyName","clone","WordArray","words","sigBytes","encoder","Hex","concat","wordArray","thisWords","thatWords","thisSigBytes","thatSigBytes","clamp","thatByte","call","slice","random","nBytes","push","C_enc","enc","hexChars","bite","join","hexStr","hexStrLength","parseInt","substr","Latin1","latin1Chars","String","fromCharCode","latin1Str","latin1StrLength","charCodeAt","Utf8","decodeURIComponent","escape","e","utf8Str","unescape","encodeURIComponent","BufferedBlockAlgorithm","reset","_data","_nDataBytes","_append","data","_process","doFlush","processedWords","dataWords","dataSigBytes","blockSize","nBlocksReady","nWordsReady","_minBufferSize","nBytesReady","offset","_doProcessBlock","splice","C_algo","Hasher","cfg","_doReset","update","messageUpdate","finalize","_doFinalize","_createHelper","hasher","message","_createHmacHelper","key","HMAC","algo","H","K","isPrime","sqrtN","sqrt","factor","getFractionalBits","nPrime","pow","W","SHA256","_hash","M","b","d","f","h","gamma0x","gamma0","gamma1x","gamma1","maj","sigma0","t1","nBitsTotal","nBitsLeft","floor","HmacSHA256","defineProperty","value","P","beta","P_DIV4_1","weistrass","USE_ENDOMORPHISM","JacobianPoint","z","p","TypeError","points","toInv","nums","len","scratch","Array","acc","invert","tmp","invertBatch","map","toAffine","toAffineBatch","fromAffine","other","az2","az3","bz2","bz3","X1","Y1","Z1","D","E","X3","Y3","Z3","X2","Y2","Z2","Z1Z1","Z2Z2","U1","S1","S2","double","ZERO","HH","HHH","V","scalar","k1neg","k1","k2neg","k2","splitScalarEndo","k1p","k2p","negate","windows","base","affinePoint","BASE","_WINDOW_SIZE","precomputes","pointPrecomputes","get","precomputeWindow","normalizeZ","set","windowSize","mask","maxNumber","shiftBy","wbits","cached","abs","point","fake","f1p","f2p","wNAF","invZ","invZ2","WeakMap","delete","bytes","bytesToNumber","powMod","assertValidity","hex","hexToBytes","fromX","header","fromCompressedHex","fromUncompressedHex","privateKey","normalizePrivateKey","msgHash","signature","recovery","sign","normalizeSignature","rinv","hexToNumber","P_","fromHex","pad64","sP","multiplyUnsafe","hG","isCompressed","toHex","toRawBytes","sliceDer","Signature","bytesToHex","check1","parseByte","check2","rEnd","sLen","sStart","sHex","numberToHex","rHex","rLen","concatBytes","arrays","reduce","arr","pad","uint8a","num","pad32b","array","j","power","order","res","number","modulo","gcd","u","q","m","egcd","k","a1","b1","c1","c2","isValidPrivateKey","calcQRSFromK","msg","priv","normalizePublicKey","publicKey","isPub","item","async","taggedHash","tag","messages","tagB","tagH","utils","sha256","createChallenge","rx","toRawX","hasEvenY","SignResult","getPublicKey","fromPrivateKey","recoverPublicKey","fromSignature","getSharedSecret","privateA","publicB","shared","recovered","canonical","h1","h1n","fill","b0","from","hmacSha256","T","qrs","getQRSrfc6979","adjustedS","sig","hashed","verify","hash","delta","truncateHash","pubKey","s1","Ghs1","Prs1","SchnorrSignature","schnorrVerify","sG","eP","R","schnorr","toHexX","auxRand","randomPrivateKey","d0","rand","k0","_setWindowSize","bytesLength","subtle","digest","createHash","ckey","importKey","name","createHmac","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__","globalThis","Function"],"mappings":"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","file":"jpake.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"jpake\"] = factory();\n\telse\n\t\troot[\"jpake\"] = factory();\n})(this, function() {\nreturn ","import * as secp from \"noble-secp256k1\";\r\nimport {randBetween, asBase64String, mod, SHA256Hash, fromBase64String} from './utils'\r\n\r\n// see: https://billatnapier.medium.com/password-juggling-in-discrete-logs-and-elliptic-curves-a82d5926d26d\r\n// https://asecuritysite.com/encryption/jpake2\r\nconst ZEROPOINT = new secp.Point(0n, 0n)\r\nconst BASEPOINT = new secp.Point(secp.CURVE.Gx, secp.CURVE.Gy)\r\n\r\ntype ZKPMsg = {\r\n    tx: string,\r\n    ty: string,\r\n    r: string,\r\n    c: string,\r\n}\r\n\r\nexport class JPake {\r\n    \r\n    // Private Variables\r\n    private x1:  bigint\r\n    private x2:  bigint\r\n    private s:   bigint\r\n\r\n    // Public Variables\r\n    x1G: secp.Point\r\n    x2G: secp.Point\r\n\r\n    // Received Variables / cached variables\r\n    x2s: bigint\r\n    otherx1G: secp.Point\r\n    otherx2G: secp.Point\r\n    otherV: secp.Point\r\n    G: secp.Point\r\n    hashFn: (str: string) => string\r\n\r\n    constructor(secret: string, hashFn: (str: string) => string = SHA256Hash) { \r\n        this.hashFn = hashFn\r\n\r\n        this.s = mod( BigInt(\"0x\" + this.hashFn(secret)), secp.CURVE.n )\r\n        this.x1 = randBetween(0n, secp.CURVE.n - 1n)\r\n        this.x2 = randBetween(0n, secp.CURVE.n - 1n)\r\n\r\n        const G = new secp.Point(secp.CURVE.Gx, secp.CURVE.Gy );\r\n        this.G = G\r\n        this.x1G = G.multiply(this.x1)\r\n        this.x2G = G.multiply(this.x2)              \r\n    }\r\n\r\n    // ZKP checks not implemented into protocol yet.\r\n    computeZKP(x: bigint, Generator: secp.Point, y: secp.Point = ZEROPOINT) : object{\r\n        // Computes a ZKP for x on Generator. We use the Fiat-Shamir heuristic:\r\n        // https://en.wikipedia.org/wiki/Fiat%E2%80%93Shamir_heuristic\r\n        // i.e. prove that we know x such that y = x.Generator\r\n        // Note that we differentiate between the point G on the curve, and the\r\n        // Generator used to compute the ZKP\r\n\r\n        // 1. Pick a random v \\in Z_q* and compute t = vG\r\n        const v = randBetween(0n, secp.CURVE.n - 1n)\r\n        const t = Generator.multiply(v)\r\n\r\n        // 2. Compute c = H(g, y, t) where H() is a cryptographic has fn\r\n        y = y.equals(ZEROPOINT) ? Generator.multiply(x) : y\r\n        const chal = asBase64String(Generator.x) + asBase64String(Generator.y) + asBase64String(t.x) + asBase64String(t.y) + asBase64String(y.x) + asBase64String(y.y)\r\n        const c = BigInt(\"0x\"+this.hashFn(chal))\r\n\r\n        // 3. Compute r = v - cx\r\n        const r = mod((v-c*x), secp.CURVE.n)\r\n\r\n        // The resulting proof is the pair (t, r).\r\n        // you can use this to verify the pair by\r\n        // calculating c = H(g, y, t) and checking if t == rG * cy.\r\n        // Here, we send over c for simplicity.\r\n        return {\r\n            tx: asBase64String(t.x),\r\n            ty: asBase64String(t.y),\r\n            r: asBase64String(r),\r\n            c: asBase64String(c),\r\n        }\r\n    }\r\n\r\n    checkZKP(tx: bigint, ty: bigint, r: bigint, G: secp.Point, y: secp.Point): boolean {\r\n        const chal = asBase64String(G.x) + asBase64String(G.y) + asBase64String(tx) + asBase64String(ty) + asBase64String(y.x) + asBase64String(y.y)\r\n        const c = BigInt(\"0x\" + this.hashFn(chal))\r\n\r\n        var Vcheck = G.multiply(r).add(y.multiply(c))\r\n        return Vcheck.equals(new secp.Point(tx, ty))\r\n    }\r\n\r\n    checkZKPSimpler(msgObj: ZKPMsg, Generator: secp.Point, y: secp.Point) {\r\n\r\n        const tx = fromBase64String(msgObj.tx)\r\n        const ty = fromBase64String(msgObj.ty)\r\n        const r = fromBase64String(msgObj.r)\r\n        const c = fromBase64String(msgObj.c)\r\n\r\n        var Vcheck = Generator.multiply(r).add(y.multiply(c))\r\n        return Vcheck.equals(new secp.Point(tx, ty))\r\n    }\r\n\r\n    Round1Message(): string{\r\n        var pubVar = {\r\n            x1Gx: asBase64String(this.x1G.x),\r\n            x1Gy: asBase64String(this.x1G.y),\r\n            x2Gx: asBase64String(this.x2G.x),\r\n            x2Gy: asBase64String(this.x2G.y),\r\n\r\n            x1ZKP: this.computeZKP(this.x1, this.G, this.x1G),\r\n            x2ZKP: this.computeZKP(this.x2, this.G, this.x2G),\r\n        }\r\n        return JSON.stringify(pubVar);\r\n    }\r\n\r\n    Round2Message(jsonStringFromB: string): string{\r\n        // In Round 1, we receive x1G and x2G from Bob, and possibly knowledge proofs for x1 and x2\r\n        const otherPubVars = JSON.parse(jsonStringFromB)\r\n        const otherx1G = new secp.Point(fromBase64String(otherPubVars.x1Gx), fromBase64String(otherPubVars.x1Gy)) // also x3G and x4G from Bob if you are following the paper\r\n        const otherx2G = new secp.Point(fromBase64String(otherPubVars.x2Gx), fromBase64String(otherPubVars.x2Gy))\r\n        \r\n        // validate ZKPs\r\n        const x1Proof = this.checkZKPSimpler(otherPubVars.x1ZKP, this.G, otherx1G)\r\n        const x2Proof = this.checkZKPSimpler(otherPubVars.x2ZKP, this.G, otherx2G)\r\n\r\n        if (!(x1Proof && x2Proof)) {\r\n            throw \"Round1 Knowledge Proof Not verified!\"\r\n        }\r\n\r\n        // These are variables which can be cached for other steps \r\n        this.otherx1G = otherx1G\r\n        this.otherx2G = otherx2G\r\n        this.x2s = this.x2 * this.s\r\n\r\n        // A = (G1 + G3 + G4) x [x2*s]\r\n        const Generator = this.x1G.add(otherx1G).add(otherx2G) // As per the RFC, the 2nd round generator is G1 + G3 + G4 in the EC setting\r\n        const A = Generator.multiply(this.x2s)\r\n\r\n        return JSON.stringify({\r\n            Ax: asBase64String(A.x),\r\n            Ay: asBase64String(A.y),\r\n\r\n            xsZKP: this.computeZKP(this.x2s, Generator, A)\r\n        })\r\n    }\r\n\r\n    computeSharedKey(jsonStringFromB: string) : string {\r\n        const otherA = JSON.parse(jsonStringFromB)\r\n        const B = new secp.Point(fromBase64String(otherA.Ax), fromBase64String(otherA.Ay))\r\n        \r\n        const ZKPGenerator = this.x1G.add(this.x2G).add(this.otherx1G)\r\n        const xsProof = this.checkZKPSimpler(otherA.xsZKP, ZKPGenerator, B)\r\n        if (!xsProof) {\r\n            throw \"Round2 Knowledge Proof Not verified!\"\r\n        }\r\n\r\n        // Ka = (B - (G4 x [x2*s])) x [x2]\r\n        const Ka = B.subtract(this.otherx2G.multiply(this.x2s)).multiply(this.x2)\r\n        const sharedKey = this.hashFn(asBase64String(Ka.x))\r\n        return sharedKey\r\n    }\r\n}\r\n","import sha256  from 'crypto-js/sha256'\r\n\r\n\r\n/* HELPER FUNCTIONS */\r\nfunction modNum (x: number, n: number): number {\r\n    return ((x % n) + n) % n\r\n}\r\n\r\nexport function mod (x: bigint, n: bigint): bigint {\r\n    return ((x % n) + n) % n\r\n}\r\n  \r\nfunction getRandomBytes (byteLength: number): Uint8Array {\r\n    const uint8Buf = new Uint8Array(byteLength)\r\n    if (typeof window == 'object' && 'crypto' in window) {\r\n        return window.crypto.getRandomValues(uint8Buf);\r\n    }\r\n    else if (typeof process === 'object' && 'node' in process.versions) {\r\n        const { randomBytes } = require('crypto');\r\n        return new Uint8Array(randomBytes(byteLength).buffer);\r\n    }\r\n    else {\r\n        throw new Error(\"The environment doesn't have randomBytes function\");\r\n    }\r\n}\r\n\r\nfunction getRandomBits (bitLength: number): Uint8Array {\r\n    const byteLength = Math.ceil(bitLength / 8) \r\n    const randBytes = getRandomBytes(byteLength)\r\n\r\n    const bitLengthMod8 = modNum(bitLength, 8)\r\n    if (bitLengthMod8) {\r\n        // randBytes[0] is the MSByte\r\n        // Fill the MSByte with leading zeros to produce the correct\r\n        // bit length\r\n        randBytes[0] = randBytes[0] & (2 ** bitLengthMod8 - 1)\r\n    }\r\n    return randBytes\r\n}\r\n\r\nexport function fromBuffer (buf: Uint8Array) {\r\n    let ret = 0n\r\n    for (const i of buf.values()) {\r\n        const bi = BigInt(i)\r\n        ret = (ret << BigInt(8)) + bi\r\n    }\r\n    return ret\r\n}\r\n\r\nfunction bitLength (a: number|bigint) {\r\n    a = BigInt(a)\r\n    if (a === 1n) { return 1 }\r\n    let bits = 1\r\n    do {\r\n        bits++\r\n    } while ((a >>= 1n) > 1n)\r\n    return bits\r\n}\r\n\r\nexport function randBetween (min: bigint, max: bigint): bigint {\r\n    if (max <= 0n || min < 0n || max <= min) throw new RangeError('Arguments MUST be: max > 0 && min >=0 && max > min')\r\n    const interval = max - min\r\n    const bitLen = bitLength(interval)\r\n    let rnd\r\n    do {\r\n      const buf = getRandomBits(bitLen)\r\n      rnd = fromBuffer(buf)\r\n    } while (rnd > interval)\r\n    const randnum = rnd + min\r\n    return randnum\r\n}\r\n\r\nexport function asPad64HexString(x: bigint, add0x: boolean = true): string {\r\n    const pad64HexString = x.toString(16).padStart(64, '0')\r\n    return add0x ? '0x' + pad64HexString : pad64HexString\r\n}\r\n\r\nexport function SHA256Hash(toHash: string): string {\r\n    var hash = sha256(toHash).toString()\r\n    return hash\r\n}\r\n\r\nexport function asBase64String( x: bigint ): string {\r\n    return BigIntBase64.fromInt(x)\r\n}\r\n\r\nexport function fromBase64String(str: string): bigint {\r\n    return BigIntBase64.toInt(str)\r\n}\r\n\r\n\r\nexport const BigIntBase64 = (function () {\r\n    var digitsStr = \r\n    //   0       8       16      24      32      40      48      56     63\r\n    //   v       v       v       v       v       v       v       v      v\r\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-\";\r\n    var digits = digitsStr.split('');\r\n    var digitsMap: {[digit: string]: bigint} = {};\r\n    for (var i = 0; i < digits.length; i++) {\r\n        digitsMap[digits[i]] = BigInt(i);\r\n    }\r\n    return {\r\n        fromInt: function(int32: bigint) {\r\n            var result = '';\r\n            while (true) {\r\n                result = digits[Number(int32 & 0x3fn)] + result; // this is safe because of the bitshifting\r\n                int32 >>= 6n; // Only good for us with unsigned integers? this should break for signed integers.\r\n                if (int32 === 0n)\r\n                    break;\r\n            }\r\n            return result;\r\n        },\r\n        toInt: function(digitsStr: string) {\r\n            var result = 0n;\r\n            var digits = digitsStr.split('');\r\n            for (var i = 0; i < digits.length; i++) {\r\n                result = (result << 6n) + digitsMap[digits[i]];\r\n            }\r\n            return result;\r\n        }\r\n    };\r\n})();",";(function (root, factory) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory();\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\troot.CryptoJS = factory();\n\t}\n}(this, function () {\n\n\t/*globals window, global, require*/\n\n\t/**\n\t * CryptoJS core components.\n\t */\n\tvar CryptoJS = CryptoJS || (function (Math, undefined) {\n\n\t    var crypto;\n\n\t    // Native crypto from window (Browser)\n\t    if (typeof window !== 'undefined' && window.crypto) {\n\t        crypto = window.crypto;\n\t    }\n\n\t    // Native (experimental IE 11) crypto from window (Browser)\n\t    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {\n\t        crypto = window.msCrypto;\n\t    }\n\n\t    // Native crypto from global (NodeJS)\n\t    if (!crypto && typeof global !== 'undefined' && global.crypto) {\n\t        crypto = global.crypto;\n\t    }\n\n\t    // Native crypto import via require (NodeJS)\n\t    if (!crypto && typeof require === 'function') {\n\t        try {\n\t            crypto = require('crypto');\n\t        } catch (err) {}\n\t    }\n\n\t    /*\n\t     * Cryptographically secure pseudorandom number generator\n\t     *\n\t     * As Math.random() is cryptographically not safe to use\n\t     */\n\t    var cryptoSecureRandomInt = function () {\n\t        if (crypto) {\n\t            // Use getRandomValues method (Browser)\n\t            if (typeof crypto.getRandomValues === 'function') {\n\t                try {\n\t                    return crypto.getRandomValues(new Uint32Array(1))[0];\n\t                } catch (err) {}\n\t            }\n\n\t            // Use randomBytes method (NodeJS)\n\t            if (typeof crypto.randomBytes === 'function') {\n\t                try {\n\t                    return crypto.randomBytes(4).readInt32LE();\n\t                } catch (err) {}\n\t            }\n\t        }\n\n\t        throw new Error('Native crypto module could not be used to get secure random number.');\n\t    };\n\n\t    /*\n\t     * Local polyfill of Object.create\n\n\t     */\n\t    var create = Object.create || (function () {\n\t        function F() {}\n\n\t        return function (obj) {\n\t            var subtype;\n\n\t            F.prototype = obj;\n\n\t            subtype = new F();\n\n\t            F.prototype = null;\n\n\t            return subtype;\n\t        };\n\t    }())\n\n\t    /**\n\t     * CryptoJS namespace.\n\t     */\n\t    var C = {};\n\n\t    /**\n\t     * Library namespace.\n\t     */\n\t    var C_lib = C.lib = {};\n\n\t    /**\n\t     * Base object for prototypal inheritance.\n\t     */\n\t    var Base = C_lib.Base = (function () {\n\n\n\t        return {\n\t            /**\n\t             * Creates a new object that inherits from this object.\n\t             *\n\t             * @param {Object} overrides Properties to copy into the new object.\n\t             *\n\t             * @return {Object} The new object.\n\t             *\n\t             * @static\n\t             *\n\t             * @example\n\t             *\n\t             *     var MyType = CryptoJS.lib.Base.extend({\n\t             *         field: 'value',\n\t             *\n\t             *         method: function () {\n\t             *         }\n\t             *     });\n\t             */\n\t            extend: function (overrides) {\n\t                // Spawn\n\t                var subtype = create(this);\n\n\t                // Augment\n\t                if (overrides) {\n\t                    subtype.mixIn(overrides);\n\t                }\n\n\t                // Create default initializer\n\t                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {\n\t                    subtype.init = function () {\n\t                        subtype.$super.init.apply(this, arguments);\n\t                    };\n\t                }\n\n\t                // Initializer's prototype is the subtype object\n\t                subtype.init.prototype = subtype;\n\n\t                // Reference supertype\n\t                subtype.$super = this;\n\n\t                return subtype;\n\t            },\n\n\t            /**\n\t             * Extends this object and runs the init method.\n\t             * Arguments to create() will be passed to init().\n\t             *\n\t             * @return {Object} The new object.\n\t             *\n\t             * @static\n\t             *\n\t             * @example\n\t             *\n\t             *     var instance = MyType.create();\n\t             */\n\t            create: function () {\n\t                var instance = this.extend();\n\t                instance.init.apply(instance, arguments);\n\n\t                return instance;\n\t            },\n\n\t            /**\n\t             * Initializes a newly created object.\n\t             * Override this method to add some logic when your objects are created.\n\t             *\n\t             * @example\n\t             *\n\t             *     var MyType = CryptoJS.lib.Base.extend({\n\t             *         init: function () {\n\t             *             // ...\n\t             *         }\n\t             *     });\n\t             */\n\t            init: function () {\n\t            },\n\n\t            /**\n\t             * Copies properties into this object.\n\t             *\n\t             * @param {Object} properties The properties to mix in.\n\t             *\n\t             * @example\n\t             *\n\t             *     MyType.mixIn({\n\t             *         field: 'value'\n\t             *     });\n\t             */\n\t            mixIn: function (properties) {\n\t                for (var propertyName in properties) {\n\t                    if (properties.hasOwnProperty(propertyName)) {\n\t                        this[propertyName] = properties[propertyName];\n\t                    }\n\t                }\n\n\t                // IE won't copy toString using the loop above\n\t                if (properties.hasOwnProperty('toString')) {\n\t                    this.toString = properties.toString;\n\t                }\n\t            },\n\n\t            /**\n\t             * Creates a copy of this object.\n\t             *\n\t             * @return {Object} The clone.\n\t             *\n\t             * @example\n\t             *\n\t             *     var clone = instance.clone();\n\t             */\n\t            clone: function () {\n\t                return this.init.prototype.extend(this);\n\t            }\n\t        };\n\t    }());\n\n\t    /**\n\t     * An array of 32-bit words.\n\t     *\n\t     * @property {Array} words The array of 32-bit words.\n\t     * @property {number} sigBytes The number of significant bytes in this word array.\n\t     */\n\t    var WordArray = C_lib.WordArray = Base.extend({\n\t        /**\n\t         * Initializes a newly created word array.\n\t         *\n\t         * @param {Array} words (Optional) An array of 32-bit words.\n\t         * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.lib.WordArray.create();\n\t         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);\n\t         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);\n\t         */\n\t        init: function (words, sigBytes) {\n\t            words = this.words = words || [];\n\n\t            if (sigBytes != undefined) {\n\t                this.sigBytes = sigBytes;\n\t            } else {\n\t                this.sigBytes = words.length * 4;\n\t            }\n\t        },\n\n\t        /**\n\t         * Converts this word array to a string.\n\t         *\n\t         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n\t         *\n\t         * @return {string} The stringified word array.\n\t         *\n\t         * @example\n\t         *\n\t         *     var string = wordArray + '';\n\t         *     var string = wordArray.toString();\n\t         *     var string = wordArray.toString(CryptoJS.enc.Utf8);\n\t         */\n\t        toString: function (encoder) {\n\t            return (encoder || Hex).stringify(this);\n\t        },\n\n\t        /**\n\t         * Concatenates a word array to this word array.\n\t         *\n\t         * @param {WordArray} wordArray The word array to append.\n\t         *\n\t         * @return {WordArray} This word array.\n\t         *\n\t         * @example\n\t         *\n\t         *     wordArray1.concat(wordArray2);\n\t         */\n\t        concat: function (wordArray) {\n\t            // Shortcuts\n\t            var thisWords = this.words;\n\t            var thatWords = wordArray.words;\n\t            var thisSigBytes = this.sigBytes;\n\t            var thatSigBytes = wordArray.sigBytes;\n\n\t            // Clamp excess bits\n\t            this.clamp();\n\n\t            // Concat\n\t            if (thisSigBytes % 4) {\n\t                // Copy one byte at a time\n\t                for (var i = 0; i < thatSigBytes; i++) {\n\t                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);\n\t                }\n\t            } else {\n\t                // Copy one word at a time\n\t                for (var i = 0; i < thatSigBytes; i += 4) {\n\t                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];\n\t                }\n\t            }\n\t            this.sigBytes += thatSigBytes;\n\n\t            // Chainable\n\t            return this;\n\t        },\n\n\t        /**\n\t         * Removes insignificant bits.\n\t         *\n\t         * @example\n\t         *\n\t         *     wordArray.clamp();\n\t         */\n\t        clamp: function () {\n\t            // Shortcuts\n\t            var words = this.words;\n\t            var sigBytes = this.sigBytes;\n\n\t            // Clamp\n\t            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);\n\t            words.length = Math.ceil(sigBytes / 4);\n\t        },\n\n\t        /**\n\t         * Creates a copy of this word array.\n\t         *\n\t         * @return {WordArray} The clone.\n\t         *\n\t         * @example\n\t         *\n\t         *     var clone = wordArray.clone();\n\t         */\n\t        clone: function () {\n\t            var clone = Base.clone.call(this);\n\t            clone.words = this.words.slice(0);\n\n\t            return clone;\n\t        },\n\n\t        /**\n\t         * Creates a word array filled with random bytes.\n\t         *\n\t         * @param {number} nBytes The number of random bytes to generate.\n\t         *\n\t         * @return {WordArray} The random word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.lib.WordArray.random(16);\n\t         */\n\t        random: function (nBytes) {\n\t            var words = [];\n\n\t            for (var i = 0; i < nBytes; i += 4) {\n\t                words.push(cryptoSecureRandomInt());\n\t            }\n\n\t            return new WordArray.init(words, nBytes);\n\t        }\n\t    });\n\n\t    /**\n\t     * Encoder namespace.\n\t     */\n\t    var C_enc = C.enc = {};\n\n\t    /**\n\t     * Hex encoding strategy.\n\t     */\n\t    var Hex = C_enc.Hex = {\n\t        /**\n\t         * Converts a word array to a hex string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The hex string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var hexChars = [];\n\t            for (var i = 0; i < sigBytes; i++) {\n\t                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                hexChars.push((bite >>> 4).toString(16));\n\t                hexChars.push((bite & 0x0f).toString(16));\n\t            }\n\n\t            return hexChars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a hex string to a word array.\n\t         *\n\t         * @param {string} hexStr The hex string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);\n\t         */\n\t        parse: function (hexStr) {\n\t            // Shortcut\n\t            var hexStrLength = hexStr.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < hexStrLength; i += 2) {\n\t                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\n\t            }\n\n\t            return new WordArray.init(words, hexStrLength / 2);\n\t        }\n\t    };\n\n\t    /**\n\t     * Latin1 encoding strategy.\n\t     */\n\t    var Latin1 = C_enc.Latin1 = {\n\t        /**\n\t         * Converts a word array to a Latin1 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The Latin1 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var latin1Chars = [];\n\t            for (var i = 0; i < sigBytes; i++) {\n\t                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                latin1Chars.push(String.fromCharCode(bite));\n\t            }\n\n\t            return latin1Chars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a Latin1 string to a word array.\n\t         *\n\t         * @param {string} latin1Str The Latin1 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);\n\t         */\n\t        parse: function (latin1Str) {\n\t            // Shortcut\n\t            var latin1StrLength = latin1Str.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < latin1StrLength; i++) {\n\t                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\n\t            }\n\n\t            return new WordArray.init(words, latin1StrLength);\n\t        }\n\t    };\n\n\t    /**\n\t     * UTF-8 encoding strategy.\n\t     */\n\t    var Utf8 = C_enc.Utf8 = {\n\t        /**\n\t         * Converts a word array to a UTF-8 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The UTF-8 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            try {\n\t                return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n\t            } catch (e) {\n\t                throw new Error('Malformed UTF-8 data');\n\t            }\n\t        },\n\n\t        /**\n\t         * Converts a UTF-8 string to a word array.\n\t         *\n\t         * @param {string} utf8Str The UTF-8 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);\n\t         */\n\t        parse: function (utf8Str) {\n\t            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n\t        }\n\t    };\n\n\t    /**\n\t     * Abstract buffered block algorithm template.\n\t     *\n\t     * The property blockSize must be implemented in a concrete subtype.\n\t     *\n\t     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0\n\t     */\n\t    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({\n\t        /**\n\t         * Resets this block algorithm's data buffer to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     bufferedBlockAlgorithm.reset();\n\t         */\n\t        reset: function () {\n\t            // Initial values\n\t            this._data = new WordArray.init();\n\t            this._nDataBytes = 0;\n\t        },\n\n\t        /**\n\t         * Adds new data to this block algorithm's buffer.\n\t         *\n\t         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.\n\t         *\n\t         * @example\n\t         *\n\t         *     bufferedBlockAlgorithm._append('data');\n\t         *     bufferedBlockAlgorithm._append(wordArray);\n\t         */\n\t        _append: function (data) {\n\t            // Convert string to WordArray, else assume WordArray already\n\t            if (typeof data == 'string') {\n\t                data = Utf8.parse(data);\n\t            }\n\n\t            // Append\n\t            this._data.concat(data);\n\t            this._nDataBytes += data.sigBytes;\n\t        },\n\n\t        /**\n\t         * Processes available data blocks.\n\t         *\n\t         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n\t         *\n\t         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\n\t         *\n\t         * @return {WordArray} The processed data.\n\t         *\n\t         * @example\n\t         *\n\t         *     var processedData = bufferedBlockAlgorithm._process();\n\t         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');\n\t         */\n\t        _process: function (doFlush) {\n\t            var processedWords;\n\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\t            var dataSigBytes = data.sigBytes;\n\t            var blockSize = this.blockSize;\n\t            var blockSizeBytes = blockSize * 4;\n\n\t            // Count blocks ready\n\t            var nBlocksReady = dataSigBytes / blockSizeBytes;\n\t            if (doFlush) {\n\t                // Round up to include partial blocks\n\t                nBlocksReady = Math.ceil(nBlocksReady);\n\t            } else {\n\t                // Round down to include only full blocks,\n\t                // less the number of blocks that must remain in the buffer\n\t                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n\t            }\n\n\t            // Count words ready\n\t            var nWordsReady = nBlocksReady * blockSize;\n\n\t            // Count bytes ready\n\t            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n\n\t            // Process blocks\n\t            if (nWordsReady) {\n\t                for (var offset = 0; offset < nWordsReady; offset += blockSize) {\n\t                    // Perform concrete-algorithm logic\n\t                    this._doProcessBlock(dataWords, offset);\n\t                }\n\n\t                // Remove processed words\n\t                processedWords = dataWords.splice(0, nWordsReady);\n\t                data.sigBytes -= nBytesReady;\n\t            }\n\n\t            // Return processed words\n\t            return new WordArray.init(processedWords, nBytesReady);\n\t        },\n\n\t        /**\n\t         * Creates a copy of this object.\n\t         *\n\t         * @return {Object} The clone.\n\t         *\n\t         * @example\n\t         *\n\t         *     var clone = bufferedBlockAlgorithm.clone();\n\t         */\n\t        clone: function () {\n\t            var clone = Base.clone.call(this);\n\t            clone._data = this._data.clone();\n\n\t            return clone;\n\t        },\n\n\t        _minBufferSize: 0\n\t    });\n\n\t    /**\n\t     * Abstract hasher template.\n\t     *\n\t     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)\n\t     */\n\t    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({\n\t        /**\n\t         * Configuration options.\n\t         */\n\t        cfg: Base.extend(),\n\n\t        /**\n\t         * Initializes a newly created hasher.\n\t         *\n\t         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hasher = CryptoJS.algo.SHA256.create();\n\t         */\n\t        init: function (cfg) {\n\t            // Apply config defaults\n\t            this.cfg = this.cfg.extend(cfg);\n\n\t            // Set initial values\n\t            this.reset();\n\t        },\n\n\t        /**\n\t         * Resets this hasher to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     hasher.reset();\n\t         */\n\t        reset: function () {\n\t            // Reset data buffer\n\t            BufferedBlockAlgorithm.reset.call(this);\n\n\t            // Perform concrete-hasher logic\n\t            this._doReset();\n\t        },\n\n\t        /**\n\t         * Updates this hasher with a message.\n\t         *\n\t         * @param {WordArray|string} messageUpdate The message to append.\n\t         *\n\t         * @return {Hasher} This hasher.\n\t         *\n\t         * @example\n\t         *\n\t         *     hasher.update('message');\n\t         *     hasher.update(wordArray);\n\t         */\n\t        update: function (messageUpdate) {\n\t            // Append\n\t            this._append(messageUpdate);\n\n\t            // Update the hash\n\t            this._process();\n\n\t            // Chainable\n\t            return this;\n\t        },\n\n\t        /**\n\t         * Finalizes the hash computation.\n\t         * Note that the finalize operation is effectively a destructive, read-once operation.\n\t         *\n\t         * @param {WordArray|string} messageUpdate (Optional) A final message update.\n\t         *\n\t         * @return {WordArray} The hash.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hash = hasher.finalize();\n\t         *     var hash = hasher.finalize('message');\n\t         *     var hash = hasher.finalize(wordArray);\n\t         */\n\t        finalize: function (messageUpdate) {\n\t            // Final message update\n\t            if (messageUpdate) {\n\t                this._append(messageUpdate);\n\t            }\n\n\t            // Perform concrete-hasher logic\n\t            var hash = this._doFinalize();\n\n\t            return hash;\n\t        },\n\n\t        blockSize: 512/32,\n\n\t        /**\n\t         * Creates a shortcut function to a hasher's object interface.\n\t         *\n\t         * @param {Hasher} hasher The hasher to create a helper for.\n\t         *\n\t         * @return {Function} The shortcut function.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);\n\t         */\n\t        _createHelper: function (hasher) {\n\t            return function (message, cfg) {\n\t                return new hasher.init(cfg).finalize(message);\n\t            };\n\t        },\n\n\t        /**\n\t         * Creates a shortcut function to the HMAC's object interface.\n\t         *\n\t         * @param {Hasher} hasher The hasher to use in this HMAC helper.\n\t         *\n\t         * @return {Function} The shortcut function.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);\n\t         */\n\t        _createHmacHelper: function (hasher) {\n\t            return function (message, key) {\n\t                return new C_algo.HMAC.init(hasher, key).finalize(message);\n\t            };\n\t        }\n\t    });\n\n\t    /**\n\t     * Algorithm namespace.\n\t     */\n\t    var C_algo = C.algo = {};\n\n\t    return C;\n\t}(Math));\n\n\n\treturn CryptoJS;\n\n}));",";(function (root, factory) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t(function (Math) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_algo = C.algo;\n\n\t    // Initialization and round constants tables\n\t    var H = [];\n\t    var K = [];\n\n\t    // Compute constants\n\t    (function () {\n\t        function isPrime(n) {\n\t            var sqrtN = Math.sqrt(n);\n\t            for (var factor = 2; factor <= sqrtN; factor++) {\n\t                if (!(n % factor)) {\n\t                    return false;\n\t                }\n\t            }\n\n\t            return true;\n\t        }\n\n\t        function getFractionalBits(n) {\n\t            return ((n - (n | 0)) * 0x100000000) | 0;\n\t        }\n\n\t        var n = 2;\n\t        var nPrime = 0;\n\t        while (nPrime < 64) {\n\t            if (isPrime(n)) {\n\t                if (nPrime < 8) {\n\t                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));\n\t                }\n\t                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));\n\n\t                nPrime++;\n\t            }\n\n\t            n++;\n\t        }\n\t    }());\n\n\t    // Reusable object\n\t    var W = [];\n\n\t    /**\n\t     * SHA-256 hash algorithm.\n\t     */\n\t    var SHA256 = C_algo.SHA256 = Hasher.extend({\n\t        _doReset: function () {\n\t            this._hash = new WordArray.init(H.slice(0));\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcut\n\t            var H = this._hash.words;\n\n\t            // Working variables\n\t            var a = H[0];\n\t            var b = H[1];\n\t            var c = H[2];\n\t            var d = H[3];\n\t            var e = H[4];\n\t            var f = H[5];\n\t            var g = H[6];\n\t            var h = H[7];\n\n\t            // Computation\n\t            for (var i = 0; i < 64; i++) {\n\t                if (i < 16) {\n\t                    W[i] = M[offset + i] | 0;\n\t                } else {\n\t                    var gamma0x = W[i - 15];\n\t                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^\n\t                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^\n\t                                   (gamma0x >>> 3);\n\n\t                    var gamma1x = W[i - 2];\n\t                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^\n\t                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^\n\t                                   (gamma1x >>> 10);\n\n\t                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n\t                }\n\n\t                var ch  = (e & f) ^ (~e & g);\n\t                var maj = (a & b) ^ (a & c) ^ (b & c);\n\n\t                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));\n\t                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));\n\n\t                var t1 = h + sigma1 + ch + K[i] + W[i];\n\t                var t2 = sigma0 + maj;\n\n\t                h = g;\n\t                g = f;\n\t                f = e;\n\t                e = (d + t1) | 0;\n\t                d = c;\n\t                c = b;\n\t                b = a;\n\t                a = (t1 + t2) | 0;\n\t            }\n\n\t            // Intermediate hash value\n\t            H[0] = (H[0] + a) | 0;\n\t            H[1] = (H[1] + b) | 0;\n\t            H[2] = (H[2] + c) | 0;\n\t            H[3] = (H[3] + d) | 0;\n\t            H[4] = (H[4] + e) | 0;\n\t            H[5] = (H[5] + f) | 0;\n\t            H[6] = (H[6] + g) | 0;\n\t            H[7] = (H[7] + h) | 0;\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n\t            data.sigBytes = dataWords.length * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Return final computed hash\n\t            return this._hash;\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\t            clone._hash = this._hash.clone();\n\n\t            return clone;\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA256('message');\n\t     *     var hash = CryptoJS.SHA256(wordArray);\n\t     */\n\t    C.SHA256 = Hasher._createHelper(SHA256);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA256(message, key);\n\t     */\n\t    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);\n\t}(Math));\n\n\n\treturn CryptoJS.SHA256;\n\n}));","'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst CURVE = {\n    a: 0n,\n    b: 7n,\n    P: 2n ** 256n - 2n ** 32n - 977n,\n    n: 2n ** 256n - 432420386565659656852420866394968145599n,\n    h: 1n,\n    Gx: 55066263022277343669578718895168534326250603453777594175500187360389116729240n,\n    Gy: 32670510020758816978083085130507043184471273380659243275938904335757337482424n,\n    beta: 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501een,\n};\nexports.CURVE = CURVE;\nconst PRIME_SIZE = 256;\nconst P_DIV4_1 = (CURVE.P + 1n) / 4n;\nfunction weistrass(x) {\n    const { a, b } = CURVE;\n    return mod(x ** 3n + a * x + b);\n}\nconst USE_ENDOMORPHISM = CURVE.a === 0n;\nclass JacobianPoint {\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    static fromAffine(p) {\n        if (!(p instanceof Point)) {\n            throw new TypeError('JacobianPoint#fromAffine: expected Point');\n        }\n        return new JacobianPoint(p.x, p.y, 1n);\n    }\n    static toAffineBatch(points) {\n        const toInv = invertBatch(points.map((p) => p.z));\n        return points.map((p, i) => p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n        return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);\n    }\n    equals(other) {\n        const a = this;\n        const b = other;\n        const az2 = mod(a.z * a.z);\n        const az3 = mod(a.z * az2);\n        const bz2 = mod(b.z * b.z);\n        const bz3 = mod(b.z * bz2);\n        return mod(a.x * bz2) === mod(az2 * b.x) && mod(a.y * bz3) === mod(az3 * b.y);\n    }\n    negate() {\n        return new JacobianPoint(this.x, mod(-this.y), this.z);\n    }\n    double() {\n        const X1 = this.x;\n        const Y1 = this.y;\n        const Z1 = this.z;\n        const A = X1 ** 2n;\n        const B = Y1 ** 2n;\n        const C = B ** 2n;\n        const D = 2n * ((X1 + B) ** 2n - A - C);\n        const E = 3n * A;\n        const F = E ** 2n;\n        const X3 = mod(F - 2n * D);\n        const Y3 = mod(E * (D - X3) - 8n * C);\n        const Z3 = mod(2n * Y1 * Z1);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    add(other) {\n        if (!(other instanceof JacobianPoint)) {\n            throw new TypeError('JacobianPoint#add: expected JacobianPoint');\n        }\n        const X1 = this.x;\n        const Y1 = this.y;\n        const Z1 = this.z;\n        const X2 = other.x;\n        const Y2 = other.y;\n        const Z2 = other.z;\n        if (X2 === 0n || Y2 === 0n)\n            return this;\n        if (X1 === 0n || Y1 === 0n)\n            return other;\n        const Z1Z1 = Z1 ** 2n;\n        const Z2Z2 = Z2 ** 2n;\n        const U1 = X1 * Z2Z2;\n        const U2 = X2 * Z1Z1;\n        const S1 = Y1 * Z2 * Z2Z2;\n        const S2 = Y2 * Z1 * Z1Z1;\n        const H = mod(U2 - U1);\n        const r = mod(S2 - S1);\n        if (H === 0n) {\n            if (r === 0n) {\n                return this.double();\n            }\n            else {\n                return JacobianPoint.ZERO;\n            }\n        }\n        const HH = mod(H ** 2n);\n        const HHH = mod(H * HH);\n        const V = U1 * HH;\n        const X3 = mod(r ** 2n - HHH - 2n * V);\n        const Y3 = mod(r * (V - X3) - S1 * HHH);\n        const Z3 = mod(Z1 * Z2 * H);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    multiplyUnsafe(scalar) {\n        if (typeof scalar !== 'number' && typeof scalar !== 'bigint') {\n            throw new TypeError('Point#multiply: expected number or bigint');\n        }\n        let n = mod(BigInt(scalar), CURVE.n);\n        if (n <= 0) {\n            throw new Error('Point#multiply: invalid scalar, expected positive integer');\n        }\n        if (!USE_ENDOMORPHISM) {\n            let p = JacobianPoint.ZERO;\n            let d = this;\n            while (n > 0n) {\n                if (n & 1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= 1n;\n            }\n            return p;\n        }\n        let [k1neg, k1, k2neg, k2] = splitScalarEndo(n);\n        let k1p = JacobianPoint.ZERO;\n        let k2p = JacobianPoint.ZERO;\n        let d = this;\n        while (k1 > 0n || k2 > 0n) {\n            if (k1 & 1n)\n                k1p = k1p.add(d);\n            if (k2 & 1n)\n                k2p = k2p.add(d);\n            d = d.double();\n            k1 >>= 1n;\n            k2 >>= 1n;\n        }\n        if (k1neg)\n            k1p = k1p.negate();\n        if (k2neg)\n            k2p = k2p.negate();\n        k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);\n        return k1p.add(k2p);\n    }\n    precomputeWindow(W) {\n        const windows = USE_ENDOMORPHISM ? 128 / W + 2 : 256 / W + 1;\n        let points = [];\n        let p = this;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            for (let i = 1; i < 2 ** (W - 1); i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    wNAF(n, affinePoint) {\n        if (!affinePoint && this.equals(JacobianPoint.BASE))\n            affinePoint = Point.BASE;\n        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;\n        if (256 % W) {\n            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n        }\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n        if (!precomputes) {\n            precomputes = this.precomputeWindow(W);\n            if (affinePoint && W !== 1) {\n                precomputes = JacobianPoint.normalizeZ(precomputes);\n                pointPrecomputes.set(affinePoint, precomputes);\n            }\n        }\n        let p = JacobianPoint.ZERO;\n        let f = JacobianPoint.ZERO;\n        const windows = USE_ENDOMORPHISM ? 128 / W + 2 : 256 / W + 1;\n        const windowSize = 2 ** (W - 1);\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for (let window = 0; window < windows; window++) {\n            const offset = window * windowSize;\n            let wbits = Number(n & mask);\n            n >>= shiftBy;\n            if (wbits > windowSize) {\n                wbits -= maxNumber;\n                n += 1n;\n            }\n            if (wbits === 0) {\n                f = f.add(window % 2 ? precomputes[offset].negate() : precomputes[offset]);\n            }\n            else {\n                const cached = precomputes[offset + Math.abs(wbits) - 1];\n                p = p.add(wbits < 0 ? cached.negate() : cached);\n            }\n        }\n        return [p, f];\n    }\n    multiply(scalar, affinePoint) {\n        if (typeof scalar !== 'number' && typeof scalar !== 'bigint') {\n            throw new TypeError('Point#multiply: expected number or bigint');\n        }\n        let n = mod(BigInt(scalar), CURVE.n);\n        if (n <= 0) {\n            throw new Error('Point#multiply: invalid scalar, expected positive integer');\n        }\n        let point;\n        let fake;\n        if (USE_ENDOMORPHISM) {\n            const [k1neg, k1, k2neg, k2] = splitScalarEndo(n);\n            let k1p, k2p, f1p, f2p;\n            [k1p, f1p] = this.wNAF(k1, affinePoint);\n            [k2p, f2p] = this.wNAF(k2, affinePoint);\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);\n            [point, fake] = [k1p.add(k2p), f1p.add(f2p)];\n        }\n        else {\n            [point, fake] = this.wNAF(n, affinePoint);\n        }\n        return JacobianPoint.normalizeZ([point, fake])[0];\n    }\n    toAffine(invZ = invert(this.z)) {\n        const invZ2 = invZ ** 2n;\n        const x = mod(this.x * invZ2);\n        const y = mod(this.y * invZ2 * invZ);\n        return new Point(x, y);\n    }\n}\nJacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, 1n);\nJacobianPoint.ZERO = new JacobianPoint(0n, 1n, 0n);\nconst pointPrecomputes = new WeakMap();\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n    }\n    static fromX(bytes) {\n        const x = bytesToNumber(bytes);\n        const sqrY = weistrass(x);\n        let y = powMod(sqrY, P_DIV4_1, CURVE.P);\n        const isYOdd = (y & 1n) === 1n;\n        if (isYOdd)\n            y = mod(-y);\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromCompressedHex(bytes) {\n        if (bytes.length !== 33) {\n            throw new TypeError(`Point.fromHex: compressed expects 33 bytes, not ${bytes.length * 2}`);\n        }\n        const x = bytesToNumber(bytes.slice(1));\n        const sqrY = weistrass(x);\n        let y = powMod(sqrY, P_DIV4_1, CURVE.P);\n        const isFirstByteOdd = (bytes[0] & 1) === 1;\n        const isYOdd = (y & 1n) === 1n;\n        if (isFirstByteOdd !== isYOdd)\n            y = mod(-y);\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromUncompressedHex(bytes) {\n        if (bytes.length !== 65) {\n            throw new TypeError(`Point.fromHex: uncompressed expects 65 bytes, not ${bytes.length * 2}`);\n        }\n        const x = bytesToNumber(bytes.slice(1, 33));\n        const y = bytesToNumber(bytes.slice(33));\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromHex(hex) {\n        const bytes = hex instanceof Uint8Array ? hex : hexToBytes(hex);\n        if (bytes.length === 32)\n            return this.fromX(bytes);\n        const header = bytes[0];\n        if (header === 0x02 || header === 0x03)\n            return this.fromCompressedHex(bytes);\n        if (header === 0x04)\n            return this.fromUncompressedHex(bytes);\n        throw new TypeError('Point.fromHex: received invalid point');\n    }\n    static fromPrivateKey(privateKey) {\n        return Point.BASE.multiply(normalizePrivateKey(privateKey));\n    }\n    static fromSignature(msgHash, signature, recovery) {\n        const sign = normalizeSignature(signature);\n        const { r, s } = sign;\n        if (r === 0n || s === 0n)\n            return;\n        const rinv = invert(r, CURVE.n);\n        const h = typeof msgHash === 'string' ? hexToNumber(msgHash) : bytesToNumber(msgHash);\n        const P_ = Point.fromHex(`0${2 + (recovery & 1)}${pad64(r)}`);\n        const sP = JacobianPoint.fromAffine(P_).multiplyUnsafe(s);\n        const hG = JacobianPoint.BASE.multiply(h).negate();\n        const Q = sP.add(hG).multiplyUnsafe(rinv);\n        const point = Q.toAffine();\n        point.assertValidity();\n        return point;\n    }\n    toRawBytes(isCompressed = false) {\n        return hexToBytes(this.toHex(isCompressed));\n    }\n    toHex(isCompressed = false) {\n        const x = pad64(this.x);\n        if (isCompressed) {\n            return `${this.y & 1n ? '03' : '02'}${x}`;\n        }\n        else {\n            return `04${x}${pad64(this.y)}`;\n        }\n    }\n    toHexX() {\n        return this.toHex(true).slice(2);\n    }\n    toRawX() {\n        return this.toRawBytes(true).slice(1);\n    }\n    assertValidity() {\n        const { x, y } = this;\n        if (x === 0n || y === 0n || x >= CURVE.P || y >= CURVE.P) {\n            throw new TypeError('Point is not on elliptic curve');\n        }\n        const left = mod(y * y);\n        const right = weistrass(x);\n        const valid = (left - right) % CURVE.P === 0n;\n        if (!valid)\n            throw new TypeError('Point is not on elliptic curve');\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n        return new Point(this.x, mod(-this.y));\n    }\n    double() {\n        return JacobianPoint.fromAffine(this).double().toAffine();\n    }\n    add(other) {\n        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiply(scalar) {\n        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n}\nexports.Point = Point;\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(0n, 0n);\nfunction sliceDer(s) {\n    return parseInt(s[0], 16) >= 8 ? '00' + s : s;\n}\nclass Signature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n    }\n    static fromHex(hex) {\n        const str = hex instanceof Uint8Array ? bytesToHex(hex) : hex;\n        if (typeof str !== 'string')\n            throw new TypeError({}.toString.call(hex));\n        const check1 = str.slice(0, 2);\n        const length = parseByte(str.slice(2, 4));\n        const check2 = str.slice(4, 6);\n        if (check1 !== '30' || length !== str.length - 4 || check2 !== '02') {\n            throw new Error('Signature.fromHex: Invalid signature');\n        }\n        const rLen = parseByte(str.slice(6, 8));\n        const rEnd = 8 + rLen;\n        const r = hexToNumber(str.slice(8, rEnd));\n        const check3 = str.slice(rEnd, rEnd + 2);\n        if (check3 !== '02') {\n            throw new Error('SignResult.fromHex: Invalid signature');\n        }\n        const sLen = parseByte(str.slice(rEnd + 2, rEnd + 4));\n        const sStart = rEnd + 4;\n        const s = hexToNumber(str.slice(sStart, sStart + sLen));\n        return new Signature(r, s);\n    }\n    toRawBytes(isCompressed = false) {\n        return hexToBytes(this.toHex(isCompressed));\n    }\n    toHex(isCompressed = false) {\n        const sHex = sliceDer(numberToHex(this.s));\n        if (isCompressed)\n            return sHex;\n        const rHex = sliceDer(numberToHex(this.r));\n        const rLen = numberToHex(rHex.length / 2);\n        const sLen = numberToHex(sHex.length / 2);\n        const length = numberToHex(rHex.length / 2 + sHex.length / 2 + 4);\n        return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;\n    }\n}\nexports.Signature = Signature;\nexports.SignResult = Signature;\nfunction concatBytes(...arrays) {\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nfunction bytesToHex(uint8a) {\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += uint8a[i].toString(16).padStart(2, '0');\n    }\n    return hex;\n}\nfunction pad64(num) {\n    return num.toString(16).padStart(64, '0');\n}\nfunction pad32b(num) {\n    return hexToBytes(pad64(num));\n}\nfunction numberToHex(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToNumber: expected string, got ' + typeof hex);\n    }\n    return BigInt(`0x${hex}`);\n}\nfunction hexToBytes(hex) {\n    hex = hex.length & 1 ? `0${hex}` : hex;\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        let j = i * 2;\n        array[i] = Number.parseInt(hex.slice(j, j + 2), 16);\n    }\n    return array;\n}\nfunction bytesToNumber(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction parseByte(str) {\n    return Number.parseInt(str, 16) * 2;\n}\nfunction mod(a, b = CURVE.P) {\n    const result = a % b;\n    return result >= 0 ? result : b + result;\n}\nfunction powMod(x, power, order) {\n    let res = 1n;\n    while (power > 0) {\n        if (power & 1n) {\n            res = mod(res * x, order);\n        }\n        power >>= 1n;\n        x = mod(x * x, order);\n    }\n    return res;\n}\nfunction egcd(a, b) {\n    let [x, y, u, v] = [0n, 1n, 1n, 0n];\n    while (a !== 0n) {\n        let q = b / a;\n        let r = b % a;\n        let m = x - u * q;\n        let n = y - v * q;\n        [b, a] = [a, r];\n        [x, y] = [u, v];\n        [u, v] = [m, n];\n    }\n    const gcd = b;\n    return [gcd, x, y];\n}\nfunction invert(number, modulo = CURVE.P) {\n    if (number === 0n || modulo <= 0n) {\n        throw new Error('invert: expected positive integers');\n    }\n    const [gcd, x] = egcd(mod(number, modulo), modulo);\n    if (gcd !== 1n) {\n        throw new Error('invert: does not exist');\n    }\n    return mod(x, modulo);\n}\nfunction invertBatch(nums, n = CURVE.P) {\n    const len = nums.length;\n    const scratch = new Array(len);\n    let acc = 1n;\n    for (let i = 0; i < len; i++) {\n        if (nums[i] === 0n)\n            continue;\n        scratch[i] = acc;\n        acc = mod(acc * nums[i], n);\n    }\n    acc = invert(acc, n);\n    for (let i = len - 1; i >= 0; i--) {\n        if (nums[i] === 0n)\n            continue;\n        let tmp = mod(acc * nums[i], n);\n        nums[i] = mod(acc * scratch[i], n);\n        acc = tmp;\n    }\n    return nums;\n}\nfunction splitScalarEndo(k) {\n    const { n } = CURVE;\n    const a1 = 0x3086d221a7d46bcde86c90e49284eb15n;\n    const b1 = -0xe4437ed6010e88286f547fa90abfe4c3n;\n    const a2 = 0x114ca50f7a8e2f3f657c1108d9d44cfd8n;\n    const b2 = a1;\n    const c1 = (b2 * k) / n;\n    const c2 = (-b1 * k) / n;\n    const k1 = k - c1 * a1 - c2 * a2;\n    const k2 = -c1 * b1 - c2 * b2;\n    const k1neg = k1 < 0;\n    const k2neg = k2 < 0;\n    return [k1neg, k1neg ? -k1 : k1, k2neg, k2neg ? -k2 : k2];\n}\nfunction truncateHash(hash) {\n    hash = typeof hash === 'string' ? hash : bytesToHex(hash);\n    let msg = hexToNumber(hash || '0');\n    const delta = (hash.length / 2) * 8 - PRIME_SIZE;\n    if (delta > 0) {\n        msg = msg >> BigInt(delta);\n    }\n    if (msg >= CURVE.n) {\n        msg -= CURVE.n;\n    }\n    return msg;\n}\nasync function getQRSrfc6979(msgHash, privateKey) {\n    const num = typeof msgHash === 'string' ? hexToNumber(msgHash) : bytesToNumber(msgHash);\n    const h1 = pad32b(num);\n    const x = pad32b(privateKey);\n    const h1n = bytesToNumber(h1);\n    let v = new Uint8Array(32).fill(1);\n    let k = new Uint8Array(32).fill(0);\n    const b0 = Uint8Array.from([0x00]);\n    const b1 = Uint8Array.from([0x01]);\n    k = await exports.utils.hmacSha256(k, v, b0, x, h1);\n    v = await exports.utils.hmacSha256(k, v);\n    k = await exports.utils.hmacSha256(k, v, b1, x, h1);\n    v = await exports.utils.hmacSha256(k, v);\n    for (let i = 0; i < 1000; i++) {\n        v = await exports.utils.hmacSha256(k, v);\n        const T = bytesToNumber(v);\n        let qrs;\n        if (isValidPrivateKey(T) && (qrs = calcQRSFromK(T, h1n, privateKey))) {\n            return qrs;\n        }\n        k = await exports.utils.hmacSha256(k, v, b0);\n        v = await exports.utils.hmacSha256(k, v);\n    }\n    throw new TypeError('secp256k1: Tried 1,000 k values for sign(), all were invalid');\n}\nfunction isValidPrivateKey(privateKey) {\n    return 0 < privateKey && privateKey < CURVE.n;\n}\nfunction calcQRSFromK(k, msg, priv) {\n    const max = CURVE.n;\n    const q = Point.BASE.multiply(k);\n    const r = mod(q.x, max);\n    const s = mod(invert(k, max) * (msg + r * priv), max);\n    if (r === 0n || s === 0n)\n        return;\n    return [q, r, s];\n}\nfunction normalizePrivateKey(privateKey) {\n    if (!privateKey)\n        throw new Error(`Expected receive valid private key, not \"${privateKey}\"`);\n    let key;\n    if (privateKey instanceof Uint8Array) {\n        key = bytesToNumber(privateKey);\n    }\n    else if (typeof privateKey === 'string') {\n        key = hexToNumber(privateKey);\n    }\n    else {\n        key = BigInt(privateKey);\n    }\n    return key;\n}\nfunction normalizePublicKey(publicKey) {\n    return publicKey instanceof Point ? publicKey : Point.fromHex(publicKey);\n}\nfunction normalizeSignature(signature) {\n    return signature instanceof Signature ? signature : Signature.fromHex(signature);\n}\nfunction getPublicKey(privateKey, isCompressed = false) {\n    const point = Point.fromPrivateKey(privateKey);\n    if (typeof privateKey === 'string') {\n        return point.toHex(isCompressed);\n    }\n    return point.toRawBytes(isCompressed);\n}\nexports.getPublicKey = getPublicKey;\nfunction recoverPublicKey(msgHash, signature, recovery) {\n    const point = Point.fromSignature(msgHash, signature, recovery);\n    if (!point)\n        return;\n    return typeof msgHash === 'string' ? point.toHex() : point.toRawBytes();\n}\nexports.recoverPublicKey = recoverPublicKey;\nfunction isPub(item) {\n    const arr = item instanceof Uint8Array;\n    const str = typeof item === 'string';\n    const len = (arr || str) && item.length;\n    if (arr)\n        return len === 33 || len === 65;\n    if (str)\n        return len === 66 || len === 130;\n    if (item instanceof Point)\n        return true;\n    return false;\n}\nfunction getSharedSecret(privateA, publicB, isCompressed = false) {\n    if (isPub(privateA) && !isPub(publicB)) {\n        [privateA, publicB] = [publicB, privateA];\n    }\n    else if (!isPub(publicB)) {\n        throw new Error('Received invalid keys');\n    }\n    const b = publicB instanceof Point ? publicB : Point.fromHex(publicB);\n    b.assertValidity();\n    const shared = b.multiply(normalizePrivateKey(privateA));\n    return typeof privateA === 'string'\n        ? shared.toHex(isCompressed)\n        : shared.toRawBytes(isCompressed);\n}\nexports.getSharedSecret = getSharedSecret;\nasync function sign(msgHash, privateKey, { recovered, canonical } = {}) {\n    if (msgHash == null)\n        throw new Error(`Expected valid msgHash, not \"${msgHash}\"`);\n    const priv = normalizePrivateKey(privateKey);\n    const [q, r, s] = await getQRSrfc6979(msgHash, priv);\n    let recovery = (q.x === r ? 0 : 2) | Number(q.y & 1n);\n    let adjustedS = s;\n    const HIGH_NUMBER = CURVE.n >> 1n;\n    if (s > HIGH_NUMBER && canonical) {\n        adjustedS = CURVE.n - s;\n        recovery ^= 1;\n    }\n    const sig = new Signature(r, adjustedS);\n    const hashed = typeof msgHash === 'string' ? sig.toHex() : sig.toRawBytes();\n    return recovered ? [hashed, recovery] : hashed;\n}\nexports.sign = sign;\nfunction verify(signature, msgHash, publicKey) {\n    const h = truncateHash(msgHash);\n    const { r, s } = normalizeSignature(signature);\n    const pubKey = JacobianPoint.fromAffine(normalizePublicKey(publicKey));\n    const s1 = invert(s, CURVE.n);\n    const Ghs1 = JacobianPoint.BASE.multiply(mod(h * s1, CURVE.n));\n    const Prs1 = pubKey.multiplyUnsafe(mod(r * s1, CURVE.n));\n    const res = Ghs1.add(Prs1).toAffine();\n    return res.x === r;\n}\nexports.verify = verify;\nasync function taggedHash(tag, ...messages) {\n    const tagB = new Uint8Array(tag.split('').map((c) => c.charCodeAt(0)));\n    const tagH = await exports.utils.sha256(tagB);\n    const h = await exports.utils.sha256(concatBytes(tagH, tagH, ...messages));\n    return bytesToNumber(h);\n}\nasync function createChallenge(x, P, message) {\n    const rx = pad32b(x);\n    const t = await taggedHash('BIP0340/challenge', rx, P.toRawX(), message);\n    return mod(t, CURVE.n);\n}\nfunction hasEvenY(point) {\n    return mod(point.y, 2n) === 0n;\n}\nclass SchnorrSignature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        if (r === 0n || s === 0n || r >= CURVE.P || s >= CURVE.n)\n            throw new Error('Invalid signature');\n    }\n    static fromHex(hex) {\n        const bytes = hex instanceof Uint8Array ? hex : hexToBytes(hex);\n        if (bytes.length !== 64) {\n            throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);\n        }\n        const r = bytesToNumber(bytes.slice(0, 32));\n        const s = bytesToNumber(bytes.slice(32));\n        return new SchnorrSignature(r, s);\n    }\n    toHex() {\n        return pad64(this.r) + pad64(this.s);\n    }\n    toRawBytes() {\n        return hexToBytes(this.toHex());\n    }\n}\nfunction schnorrGetPublicKey(privateKey) {\n    const P = Point.fromPrivateKey(privateKey);\n    return typeof privateKey === 'string' ? P.toHexX() : P.toRawX();\n}\nasync function schnorrSign(msgHash, privateKey, auxRand = exports.utils.randomPrivateKey()) {\n    if (msgHash == null)\n        throw new TypeError(`Expected valid message, not \"${msgHash}\"`);\n    if (!privateKey)\n        privateKey = 0n;\n    const { n } = CURVE;\n    const m = typeof msgHash === 'string' ? hexToBytes(msgHash) : msgHash;\n    const d0 = normalizePrivateKey(privateKey);\n    if (!(0 < d0 && d0 < n))\n        throw new Error('Invalid private key');\n    const rand = typeof auxRand === 'string' ? hexToBytes(auxRand) : auxRand;\n    if (rand.length !== 32)\n        throw new TypeError('Expected 32 bytes of aux randomness');\n    const P = Point.fromPrivateKey(d0);\n    const d = hasEvenY(P) ? d0 : n - d0;\n    const t0h = await taggedHash('BIP0340/aux', rand);\n    const t = d ^ t0h;\n    const k0h = await taggedHash('BIP0340/nonce', pad32b(t), P.toRawX(), m);\n    const k0 = mod(k0h, n);\n    if (k0 === 0n)\n        throw new Error('Creation of signature failed. k is zero');\n    const R = Point.fromPrivateKey(k0);\n    const k = hasEvenY(R) ? k0 : n - k0;\n    const e = await createChallenge(R.x, P, m);\n    const sig = new SchnorrSignature(R.x, mod(k + e * d, n));\n    const isValid = await schnorrVerify(sig.toRawBytes(), m, P.toRawX());\n    if (!isValid)\n        throw new Error('Invalid signature produced');\n    return typeof msgHash === 'string' ? sig.toHex() : sig.toRawBytes();\n}\nasync function schnorrVerify(signature, msgHash, publicKey) {\n    const sig = signature instanceof SchnorrSignature ? signature : SchnorrSignature.fromHex(signature);\n    const m = typeof msgHash === 'string' ? hexToBytes(msgHash) : msgHash;\n    const P = normalizePublicKey(publicKey);\n    const e = await createChallenge(sig.r, P, m);\n    const sG = Point.fromPrivateKey(sig.s);\n    const eP = P.multiply(e);\n    const R = sG.subtract(eP);\n    if (R.equals(Point.BASE) || !hasEvenY(R) || R.x !== sig.r)\n        return false;\n    return true;\n}\nexports.schnorr = {\n    Signature: SchnorrSignature,\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n};\nPoint.BASE._setWindowSize(8);\nexports.utils = {\n    isValidPrivateKey(privateKey) {\n        return isValidPrivateKey(normalizePrivateKey(privateKey));\n    },\n    randomPrivateKey: (bytesLength = 32) => {\n        if (typeof window == 'object' && 'crypto' in window) {\n            return window.crypto.getRandomValues(new Uint8Array(bytesLength));\n        }\n        else if (typeof process === 'object' && 'node' in process.versions) {\n            const { randomBytes } = require('crypto');\n            return new Uint8Array(randomBytes(bytesLength).buffer);\n        }\n        else {\n            throw new Error(\"The environment doesn't have randomBytes function\");\n        }\n    },\n    sha256: async (message) => {\n        if (typeof window == 'object' && 'crypto' in window) {\n            const buffer = await window.crypto.subtle.digest('SHA-256', message.buffer);\n            return new Uint8Array(buffer);\n        }\n        else if (typeof process === 'object' && 'node' in process.versions) {\n            const { createHash } = require('crypto');\n            return Uint8Array.from(createHash('sha256').update(message).digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have sha256 function\");\n        }\n    },\n    hmacSha256: async (key, ...messages) => {\n        if (typeof window == 'object' && 'crypto' in window) {\n            const ckey = await window.crypto.subtle.importKey('raw', key, { name: 'HMAC', hash: { name: 'SHA-256' } }, false, ['sign']);\n            const message = concatBytes(...messages);\n            const buffer = await window.crypto.subtle.sign('HMAC', ckey, message);\n            return new Uint8Array(buffer);\n        }\n        else if (typeof process === 'object' && 'node' in process.versions) {\n            const { createHmac, randomBytes } = require('crypto');\n            const hash = createHmac('sha256', key);\n            for (let message of messages) {\n                hash.update(message);\n            }\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have hmac-sha256 function\");\n        }\n    },\n    precompute(windowSize = 8, point = Point.BASE) {\n        const cached = point === Point.BASE ? point : new Point(point.x, point.y);\n        cached._setWindowSize(windowSize);\n        cached.multiply(3n);\n        return cached;\n    },\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(905);\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();"],"sourceRoot":""}